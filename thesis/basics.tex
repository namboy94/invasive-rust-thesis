\chapter{Grundlagen}\label{sec:basics}

Im folgenden Kapitel werden die Grundlagen der Programmiersprache Rust, der Rechnerarchitektur SPARC-V8 und des 
invasiven Computing behandelt, welche zum Verständnis dieser Arbeit beitragen.

\section{Rust}

Rust ist eine relativ neue Programmiersprache, welche wie beispielsweise C++ direkte Kontrolle über die
unterliegende Hardware bieten soll. Dies bedeutet in der Praxis, dass diese Sprache nicht von einem Garbage
Collector Gebrauch macht, wie es Sprachen wie zum Beispiel X10 tun. Im Gegensatz zu C++ bietet Rust jedoch
standardmäßig Speichersicherheit und garantieren somit dass Programme keine Speicherfehler beinhalten.
\cite{theRustLanguage}

Rust erfreut sich in der jüngsten Vergangenheit wachsende Beliebtheit bei Programmierern aller Art. So wurde
bei einer Umfrage der Webseite stackoverflow.com Rust im Jahre 2016 als beliebteste Programmiersprache bei 
Entwicklern ermittelt\cite{stackoverflowSurvey}.

Das wohl derzeit prominenteste Projekt, welches Rust verwendet, ist der Servo Web Browser Engine. Dieses Projekt
wurde von Mozilla Research initialisiert, erhält jedoch ebenfalls Beiträge von Freiwilligen
als auch von Unternehmen wie Samsung.
Diese Software soll nach und nach im Mozilla Firefox Webbrowser integriert werden und hierbei eine bessere
Leistung uns Sicherheit als vorhergehende Technologien vorweisen\cite{engineeringServo}.

\subsection{Motivation}

Eine der Kernziele der Rust Programmiersprache ist es, sichere Speicherzugriffe zu gewährleisten, ohne
für diesen Zweck einen Garbage Collector zu verwenden. Fehlerhafte Speicherzugriffe können undefiniertes
Verhalten auslösen, welches ein Sicherheitsrisiko darstellen kann, denn diese Fehler können gezielt ausgenutzt
werden, um Schadcode auszuführen.\cite{engineeringServo}\cite{undefinedBehaviour}

Außerdem soll Rust paralleles Rechnen unterstützen und so möglichst effizient moderne Hardware verwenden.
Hierfür sollen gewisse häufig auftretende Fehler in der Parallelprogrammierung gänzlich entfallen.
\cite{theRustLanguage}

Rust lehnt sich konzeptionell und syntaktisch an C-ähnliche Sprachen an, enthält jedoch auch Konzepte aus der
funktionalen Programmierung. Zusätzlich werden Sprachkonzepte und Abstraktionen geboten, welche
ansonsten zumeist in höheren Programmiersprachen geboten werden. Hierdurch soll der Einstieg für
Programmierer, die zuvor keine oder nur wenige Erfahrungen mit Systemsprachen gemacht haben, erleichtert werden.
\cite{engineeringServo}

Diese zusätzliche Sicherheiten und Nutzerfreundlichkeiten sollen jedoch keine Laufzeitkonsequenzen mit sich ziehen,
denn Rust soll in dieser Hinsicht ähnliche Ergebnisse wie andere Systemsprachen, beispielsweise C oder C++,
aufweisen. Außerdem soll Rust es vereinfachen, mehrere Programmiersprachen miteinander zu verwenden. Es soll
also möglich sein, Code aus anderen Sprachen aus einem Rust Kontext zu verwenden als auch umgekehrt.\cite{rustBook}


\subsection{Das Typsystem}

Das signifikanteste Alleinstellungsmerkmal der Programmiersprache Rust ist ihr Typsystem. Dieses ermöglicht es
erst, die versprochenen Sicherheitsgarantien ohne zusätzliche Konstrukte wie einen Garbage
Collector zu realisieren.\cite{rustBook}

\subsubsection{Ownership, Move-Semantik und Borrowing}

Das Typsystem integriert das Konzept der \textit{Ownership (engl. Besitz)} ein.
Dies ist die zentrale Besonderheit von Rusts Typsystem.
Der Grundgedanke hierhinter ist es, dass der Zugriff auf eine Speicherregion einer Variable exklusiv
zur Verfügung gestellt wird. Diese Variable wird auch\textit{Owner (engl. Besitzer)} genannt.
Zu jedem Zeitpunkt darf die Speicherregion nur einen \textit{Owner} haben.
Sobald dieser \textit{Owner} den Geltungsbereich verlässt, wird die zugehörige Speicherregion freigegeben.
Dies ist der Mechanismus, der es in Rust erlaubt, Speicher ohne manuelle Befreiung oder Nutzung eine
Garbage Collectors zu verwalten.\cite{rustBook}

Die \textit{Ownership} einer Speicherregion kann mithilfe der \textit{Move}-Semantik den Besitzer wechseln.
Die kann bei Funktionsaufrufen oder auch bei einer Zuweisung geschehen. Beispiele hierfür sind in Abbildung
\ref{code:move_semantics} zu sehen.\cite{rustBook}

\begin{lstlisting}[float,caption={Beispieldarstellung der \textit{Move}-Semantik},label=code:move_semantics]
let x = 5;    // Owner: x
let y = x;    // Owner: y, x nun ungueltig
let z = f(y)  // Ownership an f uebergeben,
              // Speicherbereich ist nun befreit,
              //   da f den Geltungsbereich verlassen hat
              // y ist ungueltig
\end{lstlisting}\cite{rustBook}

Zusätzlich zur \textit{Move}-Semantik können in Rust Referenzen zu Variablen verwendet werden. Dies wird im Kontext
von Rust häufig als \textit{borrowing (engl. ausleihen)} bezeichnet. Verwendet man eine Referenz auf eine Variable,
ist der \textit{Owner} des Speicherbereichs weiterhin die originale Variable. Es gibt zwei unterschiedliche
Typen von Referenzen, veränderliche und unveränderliche Referenzen. Standardmäßig werden in Rust unveränderliche
Referenzen verwendet. Diese erlauben es nicht, den Wert des Speicherbereichs zu verändern, sondern nur auszulesen.
Es gibt keine Limitierung bei der Anzahl unveränderlicher Referenzen eine Variable besitzen kann. Im Gegensatz
hierzu kann nur eine veränderliche Referenz auf die Variable existieren. Dies ermöglicht es, bereits zur
Compile-Zeit gewisse Wettlaufsituationen, \textit{Race Conditions}, in der Parallelprogrammierung auszuschließen. 

\subsubsection{Strukturen, Implementierungen und Traits}

Zum Erstellen von benutzerdefinierten Typen bietet Rust Strukturen (\texttt{\textsc{\textbf{struct}}}),
Implementierungen (\texttt{\textsc{\textbf{impl}}}) und Traits (\texttt{\textsc{\textbf{trait}}}).

Strukturen in Rust spezifizieren benutzerdefinierte Datentypen, welche verwandte Daten vereinen. Das Konzept
ähnelt den Strukturen in C. Anders wie in C kann man jedoch mithilfe von Implementierungen Methoden und assozierte
Funktionen für diese Strukturen definieren.
Diese Möglichkeit erlaubt es eine objektorientierte Herangehensweise in Rust zu verwenden.
Implementierungen erlauben das Definieren von Methoden, welche auf einer initiierten Struktur aufgerufen werden
und eine Referenz auf \texttt{\textsc{\textbf{self}}}, also der Struktur selbst, als Parameter entgegennehmen.
Zusätzlich können Funktionen definiert werden, welche keinen solchen Parameter entgegennehmen und somit auch mit
nicht initiierten Strukturen verwendet werden kann. Dies ähnelt statischen Methoden in objektorientierten
Sprachen.

Traits sind ein Sprachkonstrukt in Rust, welches das Verhalten von Typen abstrakt definieren können. Sie ähneln sich
hierbei Interfaces aus anderen Sprachen. 

Die \textit{}

AFFINE et LINEARE TYPEN

OWNERSHIP

TRAITS, STRUCTS, IMPLS


Eine Ausnahme hierzu bilden Type, welche das "`Copy-Trait"' oder das "`Clone-Trait"'
implementieren\cite{ownership}\cite{linearTypePain}.
So können beispielsweise Variablen vom Typ i32, welches
das "`Copy-Trait"' implementiert, beliebig oft wiederverwendet werden\cite{ownership}.
In diesem Fall existieren trotzdem nicht mehrere Zeiger auf dieselbe Speicherregion, der Speicherinhalt wird stattdessen jedes
Mal kopiert.

Ein weiteres interessantes "`Trait"' welches ein Typ in Rust implementieren kann ist das "`Drop-Trait"'\cite{dropTrait}.
Implementiert ein Typ dieses,
so kann zusätzlicher Code ausgeführt werden, sobald eine Variable von dem Typ den Geltungsbereich verlässt\cite{dropTrait}.
Dies kann hilfreich sein, um Abhängigkeiten zu behandeln, welche in einem nicht-trivialen Zusammenhang von der nun
ungültigen Variable abhängen.
Beispielsweise kann eine Netzwerkverbindung korrekt geschlossen werden sobald die dazugehörige Variable den
Geltungsbereich verlässt.

Das Ownership-System wird in der Praxis von Compiler durchgesetzt. So werden die Garantien, welche das Ownership-System
verspricht, bereits zur Compile-Zeit sichergestellt. Zusätzlich fällt die Notwendigkeit für einen Garbage Collector weg, welches
zu einer besseren Laufzeitseffizienz und Determinismus im Vergleich zu Sprachen die einen Garbage Collector verwenden beitragen.
Durch das Ownership-System entstehen keine zusätzlichen Laufzeitkosten\cite{whatIsOwnership}.

%\section{Sicherheit}

%Im folgenden wird die Sicherheit bezüglich undefiniertem Verhalten als Folge von fehlerhaften Speicherzugriffen analysiert.
%Hierbei ist vor allem der Vergleich zwischen Rust und C interessant, da einige von Rusts primären Eigenschaften die
%Risiken der C-Programmierung beseitigen sollen.

%\subsection{Division durch 0}

%Dividiert man in C einen Wert durch die Zahl 0, kann es zu undefiniertem Verhalten führen, welches auf jeden Fall unerwünscht
%ist. Versucht man dies in Rust, so bricht das Programm sofort ab, indem die "`panic\char`_fmt"'-Funktion aufgerufen wird und es
%kann nicht zu undefiniertem Verhalten kommen.

%\subsection{Pufferüberlauf}

%Ein weiterer Fall, der in C zu undefiniertem Verhalten führt, sind Pufferüberläufe. Diese geschehen, wenn man beispielsweise
%in einem Array der Größe n versucht, auf das n+1te Element zuzugreifen. Wie bereits im letzten Vergleich kann dies in 
%Rust nicht geschehen, da das Programm mit einem Aufruf der "`panic\char`_fmt"'-Funktion die Ausführung beendet.

%\subsection{Nicht Initialisierte Variablen}

%In C ist es möglich, uninitialiserte Variablen zu verwenden, dies führt allerdings ebenfalls zu undefiniertem Verhalten.
%In Rust hingegen wird dies bereits vom Compiler verhindert, da er den Gebrauch von uninitialisierten Variablen verbietet.
%Ein Rust-Programm welches also uninitialisierte Variablen verwendet kompiliert also gar nicht und kann so natürlich auch nicht
%zu undefiniertem Verhalten führen.

\subsubsection{Typsystem}

Rust verfügt über ein statisches, typsicheres Typsystem, welches sich an Typsystemen aus funktionalen Sprachen, beispielsweise Haskell, anlehnt\cite{rustWikiDe}. Dies bedeutet dass jede Variable einen eindeutigen Typ besitzt und keinen
anderen Typ annehmen kann. Rust erlaubt es zudem, per Typinferenz die explizite Angabe eines Typen bei der Variablendeklaration zu
vermeiden\cite{rustWikiDe}.

Es gibt wie in den meisten statischen Typsystemen eine Handvoll von primitiven Typen. In Rust gibt es die folgenden\cite{rustTypes}:

\begin{description}
	\item[Vorzeichenlose numerische Typen] u8, u16, u32, u64
	\item[Vorzeichenbehaftete numerische Typen im Zweier-Komplement] i8, i16, i32, i64
	\item[Platformabhängige numerische Typen] usize, isize
	\item[Textuelle Typen] char, str
\end{description}

Zudem gibt es zusätzlich noch generische Konstrukte, nämlich Tupel, Arrays, Slices, Funktionszeiger, Referenzen und Zeiger, welche
auf beliebige Typen anwendbar sind\cite{rustTypes}. Funktionen in Rust erlauben den Gebrauch für generische Typen, welches es
ermöglicht, dass eine Implementierung einer solche Funktion auf mehrere Typen anwendbar ist.

Rust borgt sich Ideen von substrukturellen Typsystemen\cite{linearTypePain}. Standardmäßig verhalten sich Variablen in Rust wie
affine Typen, welches sicherstellt, dass die Variablen höchstens ein mal verwendet werden\cite{substructuralTypesWikiEn}.
Dies wird in der Funktionsweise der "`Move"'-Semantik verdeutlicht\cite{linearTypePain}.
Es ist jedoch auch möglich, durch den Gebrauch der "`Copy"'- oder "`Clone"'-Traits Variablen
beliebig oft zu verwenden\cite{linearTypePain}.
Außerdem ist es möglich, Variablen sich wie lineare Typen verhalten zu lassen, also erzwingen dass diese Variablen mindestens
ein mal verwendet werden\cite{linearTypePain}.

Rusts Objektmodell basiert auf Strukturen, Implementierungen und Traits\cite{rustWikiEn}.
Strukturen (Schlüsselwort struct) ermöglichen die Deklaration von Feldern\cite{rustWikiEn}, 
Traits (Schlüsselwort trait) bieten Polymorphie und Vererbung
\cite{rustWikiEn} und Implementierungen (Schlüsselwort impl) erfüllen eine ähnliche Rolle wie Klassen in
anderen Programmiersprachen\cite{rustWikiEn}.

\subsubsection{Paradigmen}

Unterschiedliche Programmierparadigmen nahmen einen Einfluss auf das Sprachdesign von Rust\cite{rustWikiDe}.
Unter anderem sind Elemente der funktionalen, objektorientierten und nebenläufigen Programmierung anzutreffen\cite{rustWikiDe}.
Dies ermöglicht es unterschiedlichsten Programmierern Rust zu benutzen als auch ein hohes Abstraktionsniveau zu
bieten\cite{rustWikiDe}.

\subsubsection{Fehler- und Ausnahmebehandlung}

In der Programmiersprache Rust werden Ausnahmen behandelt, in dem die "`Option"' oder "`Result"' Aufzählung (enum) als
Rückgabeparameter einer Funktion verwendet werden. Anhand dieser kann man dann prüfen, ob eine Ausnahme beim Funktionsaufruf
aufgetreten ist. Bei unbehandelten Ausnahmen wird für den aktiven Faden (Thread) die "`panic\char`_fmt"'-Funktion aufgerufen.
Bei Fehlern beendet Rust die Ausführung des Programms. 

\subsection{Architektur/Compiler}

Der offizielle Rust Compiler heißt rustc und kann eigenständige Rust-Quelldateien kompilieren. Rust-Quelldateien haben
konventionsgemäß die Dateiendung "`.rs"'. Als Lösung zum Abhängigkeitsmanagement und der Distribution wurde das Werkzeug cargo 
entwickelt. Es ermöglicht es dem Programmierer verwendete Bibliotheken in ein Projekt einzugliedern,
indem diese in einer "`Cargo.toml"' Datei im Hauptverzeichniss
des Projekts angegeben werden. Außerdem unterstützt "`cargo"' mehrere weiter hilfreiche Funktionen zum Testen oder
Distribuieren der entwickelten Software. Kompilierte Software kann als ein sogenanntes "`Crate"' bei der
von den Rust entwickelten Platform "`crates.io"' mithilfe von cargo hochgeladen werden.

Rustc und cargo ermöglichen das Kompilieren für unterschiedliche Zielarchitekturen mithilfe der "`-{}-target"'-Option.

Um den Gebrauch von unterschiedlichen rustc und cargo Versionen zu vereinfachen, wurde das Werkzeug rustup entwickelt. Dieses
Hilfsprogramm ermöglicht es unterschiedliche Varianten des Rust-Compilers zu installieren und bei Belieben zu wechseln.
Außerdem erleichtert es die Kompilierung für anderer Zielarchitekturen, indem es für unterstützte Architekturen eine
vorkompilierte Standardbibliothek herunterladen kann.

Als Compiler-Backend wird LLVM verwendet. Durch diese wird Rust vor der Übersetzung zu Maschinenbefehlen in die Zwischensprache
LLVM-IR übersetzt. Dadurch ist es möglich, Rust-Code auf allen von LLVM unterstützen Rechnerarchitekturen laufen zu lassen.


\section{SPARC und SPARC-V8}

SPARC (\textbf{S}calable \textbf{P}rocessor \textbf{ARC}hitecture) ist eine Rechnerarchitektur, welche auf das
RISC (Reduced Instruction Set Computing) Konzept aufbaut. Eines der Ziele der SPARC Architektur ist es, skalierbar
zu sein und so in unterschiedlichsten Umgebungen zum Einsatz zu kommen. So können SPARC Prozessoren in
Mikrocontrollern bis hin zu Supercomputern verwendet werden. Die Architektur wird an unterschiedliche
Halbleiter-Unternehmen lizensiert, mit dem Ziel durch konkurrierende Kräfte Innovation bezüglich Leistung oder
Kosten zu fördern.\cite{sparc}

SPARC-V8 ist eine auf SPARC basierende Architektur. Es handelt sich hierbei um eine Allzweckarchitektur mit einem
32-bit breiten Datenpfad.\cite{sparcv8Eval}

\subsection{LEON}

Die ursprünglich von der European Space Agency (ESA) und anschließend von Gaisler Research entwickelten
LEON-Prozessoren basieren auf der SPARC-V8 Architektur.
Das Hauptziel der LEON-Prozessoren war es, fehlertolerante Nachfolger zu älteren SPARC-V7-basierten
Prozessoren, die zu dem Zeitpunkt bei der ESA Verwendung fanden, zu bieten.\cite{gaislerLeon}
Es handelt sich bei ihnen um stark konfigurierbare
Implementierungen der SPARC-V8 Architektur in der Hardwarebeschreibungssprache
VHDL (Very High Speed Integrated Circuit Hardware Description Language).
Unterschiedliche Iterationen dieser Prozessorfamilie sind unter Open-Source Lizenzen als VHDL-Designs verfügbar.
So wurden die VHDL-Designs des LEON2 Prozessors unter der GNU LGPL Lizenz veröffentlicht.\cite{sparcv8Eval}
Auch das Design des LEON3 Prozessors ist unter einer Open-Source Lizenz verfügbar\cite{}.

Die Kombination von stark konfigurierbaren Designs und der Open-Source Lizenz ermöglicht den Gebrauch der
LEON VHDL Designs in domänenspezifischen, angepassten ASICs (Application-Specific Integrated Circuit),
FPGAs (Field Programmable Gate Array) oder SOCs (System On Chip). Daher eignet sich die LEON Prozessorfamilie
auch zum Einsatz im invasiven Computing, um deren neuartigen Konzepte möglichst effizient auszunutzen.
\cite{sparcv8Eval}

\section{Invasives Computing}

Invasives Computing beschreibt die Möglichkeit eines Programms auf einem Parallelrechner,
dynamisch Hardwareressourcen zu reservieren, nutzen und anschließend wieder freizugeben.\cite{octopos}

Die drei fundamentalen Phasen des invasiven Computing sind die \textit{\textbf{Invade}}, \textit{\textbf{Infect}}
und \textit{\textbf{Retreat}} Phasen. In der \textit{Invade} Phase werden zunächst die gewünschten
Hardwareressourcen angefordert und anschließend reserviert. Diese Menge an Hardwareressourcen kann dann mithilfe
eines \textit{Claims} verwaltet werden. Die zu reservierenden Ressourcen werden mithilfe von \textit{Constraints}
angegeben.
Sind die Ressourcen reserviert, kann die \textit{Infect}
Phase beginnen. In dieser werden Ausführungsfaden erstellt,
welche auf den reservierten Hardwareressourcen ausgeführt werden. Im Kontext des invasiven Computing wird ein solcher
Faden als \textit{inasive-let} oder abgekürzt als \text{i-let} bezeichnet\cite{invasiveCommonTerms}.
Benötigt das Programm die reservierten Ressourcen nicht mehr, können diese in der \textit{Retreat} Phade wieder
freigegeben werden.\cite{octopos}

Für den praktischen Einsatz des invasiven Computings wurde ein Betriebssystem namens \textit{OctoPOS} entwickelt. 
Dieses unterstützt die \textit{Invade}, \textit{Infect} und \textit{Retreat} Phasen auf der Systemebene.
Zusätzlich hierzu existiert das \textit{Invasive Run-Time Support System (IRTSS)}. Diese Middleware
\cite{invasiveRISC} fungiert als eine Hardware-Abstraktionsschicht und als
Ressourcenverwalter \cite{invasiveManyCore}.
\textit{OctoPOS} und \textit{IRTSS} bieten so eine Platform für das invasive Programmieren.\cite{octopos}

Um das Konzept des invasiven Computing möglichst effizient auszunutzen, wurden speziell an das invasive Computing
angepasste Hardware entwickelt, deren Prozessorkerne auf dem Design des LEON3 Prozessors basieren.
Diese Hardware unterstützen gewisse invasive Grundfunktionen und entlastet somit das Betriebssystem und das IRTSS.
\cite{invasiveArrays}

Zurzeit unterstützen OctoPOS und IRTSS den Einsatz der Programmiersprachen C, C++ und X10.