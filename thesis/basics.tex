\chapter{Grundlagen und Verwandte Arbeiten}\label{sec:basics}

Im Folgenden Kapitel werden die Grundlagen der Programmiersprache Rust, der Rechnerarchitektur SPARC-V8 und des invasiven Computing
behandelt, welche zum Verständnis dieser Arbeit beitragen.

\section{Rust}

Rust ist eine Programmiersprache, welche von Mozilla Research entwickelt wird\cite(rustWikDe).
Die Entwicklung der Sprache begann als persönliches Projekt des Mozilla-Mitarbeiters Graydon Hoare und wird
seit 2009 von Mozilla offiziell unterstützt \cite(rustWikDe). 2010 erschien die erste öffentliche Version der Sprache und
im Jahr 2015 wurde die erste stabile Version veröffentlicht \cite(rustWikDe). 
Sie erfreut sich in der jüngsten Vergangenheit wachsende Beliebtheit bei Programmierern aller Art. So wurde
bei einer Umfrage der Webseite stackoverflow.com Rust im Jahre 2016 als beliebteste Programmiersprache bei Entwicklern
ermittelt\cite{stackoverflowSurvey}.

Das wohl derzeit prominenteste Projekt, welches Rust verwendet, ist der Servo Layout-Engine, welcher gemeinsam von
Mozilla und Samsung entwickelt wird\cite{servoWikiDe}. Dieser Layout-Engine soll nach und nach im Mozilla Firefox Webbrowser
integriert werden und hierbei eine bessere Leistung als vorhergehende Technologien vorweisen\cite{servoWikiDe}.

\subsection{Motivation}

Eine der Kernziele der Rust Programmiersprache ist es, sichere Speicherzugriffe zu gewährleisten\cite{rustWikiDe}.
Dies wird mithilfe des sogenannten Ownership-Systems und einem besonderen, typsicheren Typsystem, wie es bei funktionalen
Programmiersprachen oft der Fall ist, \cite{rustWikiDe} erreicht. 
Das Ownership-System ermöglicht es, fehlerhafte Speicherzugriffe, welche ein ernsthaftes
Sicherheitsrisiko darstellen, zu vermeiden. Fehlerhafte Speicherzugriffe können zu undefiniertem Verhalten führen,
welches wiederum auch gezielt als Angriffsvektor genutzt werden kann.
Diese Speichersicherheit wird in Rust erreicht, anders als bei den meisten anderen Sprachen mit automatischer
Speicherverwaltung, ohne dabei von einem Garbage Collector Gebrauch
zu machen\cite{rustWikiDe}. Dies macht Rust zu einer interessanten Alternative zu Systemsprachen
wie C, welche nicht sicher bezüglich der Speicherverwaltung sind, als auch zu Sprachen mit Garbage Collector wie X10, welche durch
den Garbage Collector wiederum andere Nachteile vorweisen.

Ein weiteres Ziel der Sprache ist die Leistung. Rust soll vergleichbare Leistungen bezüglich des Laufzeitverhaltens wie andere
Systemsprachen wie C oder C++ erreichen.
Dies kann in Benchmarks zumeist auch bestätigt werden\cite{rustVsCBenchmark}. 
Benchmarks, welche Rust mit
höheren Programmiersprachen wie Java\cite{rustVsJavaBenchmark} oder Python\cite{rustVsPythonBenchmark} vergleichen,
weisen meist eine bessere Leistung von Rust auf.

Das effiziente Einbinden mit anderen Sprachen ist eine zusätzliche Motivation hinter der Programmiersprache.
So kann Rust beispielsweise mithilfe der sogenannten "`Foreign Function Interface"' (FFI)
Funktionen, welche in anderen Programmiersprachen, beispielsweise C, geschrieben sind, benutzen. Außerdem ist es möglich,
Rust Code aus anderen Programmiersprachen, inklusive höheren Programmiersprachen wie Python oder Ruby, aufzurufen.

Nebenläufigkeit ist ein weiteres Ziel der Sprache. Mithilfe des Architektur der Sprache soll es zwischen einzelnen Threads
nicht zu kritischen Wettläufen kommen, welches eines der Hauptfehlerquellen bei parallelem Programmieren beseitigt.

Rust soll dem Programmierer zudem höhere Abstraktionen bieten, welche nicht oder nur gering die Effizienz des Programm
beeinflussen. Diese sogenannten "`Zero-cost Abstractions"' erleichtern es Programmierern, welche nur wenig Erfahrung mit
Systemsprachen vorweisen können, die Programmiersprache zu verwenden, ohne dabei auf Leistung verzichten zu müssen.

\subsection{Grundlegende Eigenschaften der Sprache}

Im Folgenden werden die grundlegenden Eigenschaften der Programmiersprache Rust erläutert.

\subsubsection{Das Ownership-System}

Das signifikanteste Alleinstellungsmerkmal der Programmiersprache Rust ist das Ownership-System\cite{whatIsOwnership}.
Erst hierdurch wird die Speichersicherheit ohne Garbage Collector möglich.

Die Grundlage des Ownership-Systems ist die Bindung von Speicher an eine Variable\cite{whatIsOwnership}.
Sobald eine Variable initialisiert wird, wird Speicher für diese alloziert.
Sobald diese Variable sich allerdings nicht mehr im Geltungsbereich befindet,
wird dieser Speicher automatisch wieder freigegeben\cite{whatIsOwnership}.
Dies wird im folgenden Beispiel veranschaulicht\cite{ownership}:

\begin{verbatim}
    fn foo() {
        let v = vec![1, 2, 3]; // Alloziert Speicher
    }

    fn main() {
        foo();
        // Speicher ist bereits hier wieder freigegeben
    }
\end{verbatim}

Außerdem erlaubt es Rust keinen zwei Variablen auf denselben Speicher zu zeigen\cite{whatIsOwnership}.
So wird beispielsweise bei einer Zuweisung einer
Variable zu einer anderen der "`Besitz"' des Speichers auf die neue Variable übertragen und die alte Variable kann nun nicht mehr
verwendet werden. Dies geschieht auch wenn die Variable als Parameter in einem Funktionsaufrauf verwendet wird.
Dieses Verhalten ist als "`Move"'-Semantik bekannt. Eine Veranschaulichung dessen folgt\cite{ownership}:

\begin{verbatim}
    fn foo(v: Vec<i32>) {
        // Details unwichtig
    }

    fn main() {
	
        let v = vec![1, 2, 3];
        let w = v;  // v ist ab jetzt nicht mehr benutzbar!
        foo(w);     // w ist ab jetzt nicht mehr benutzbar!

    }
\end{verbatim}

Durch dieses Verhalten wird sichergestellt, dass eine Variable exklusiven Zugriff auf die allozierten Speicherbereiche besitzt,
wodurch fehlerhafte Speicherzugriffe vermieden werden.

Eine Ausnahme hierzu bilden Type, welche das "`Copy-Trait"' oder das "`Clone-Trait"'
implementieren\cite{ownership}\cite{linearTypePain}.
So können beispielsweise Variablen vom Typ i32, welches
das "`Copy-Trait"' implementiert, beliebig oft wiederverwendet werden\cite{ownership}.
In diesem Fall existieren trotzdem nicht mehrere Zeiger auf dieselbe Speicherregion, der Speicherinhalt wird stattdessen jedes
Mal kopiert.

Ein weiteres interessantes "`Trait"' welches ein Typ in Rust implementieren kann ist das "`Drop-Trait"'\cite{dropTrait}.
Implementiert ein Typ dieses,
so kann zusätzlicher Code ausgeführt werden, sobald eine Variable von dem Typ den Geltungsbereich verlässt\cite{dropTrait}.
Dies kann hilfreich sein, um Abhängigkeiten zu behandeln, welche in einem nicht-trivialen Zusammenhang von der nun
ungültigen Variable abhängen.
Beispielsweise kann eine Netzwerkverbindung korrekt geschlossen werden sobald die dazugehörige Variable den
Geltungsbereich verlässt.

Das Ownership-System wird in der Praxis von Compiler durchgesetzt. So werden die Garantien, welche das Ownership-System
verspricht, bereits zur Compile-Zeit sichergestellt. Zusätzlich fällt die Notwendigkeit für einen Garbage Collector weg, welches
zu einer besseren Laufzeitseffizienz und Determinismus im Vergleich zu Sprachen die einen Garbage Collector verwenden beitragen.
Durch das Ownership-System entstehen keine zusätzlichen Laufzeitkosten\cite{whatIsOwnership}.

%\section{Sicherheit}

%Im folgenden wird die Sicherheit bezüglich undefiniertem Verhalten als Folge von fehlerhaften Speicherzugriffen analysiert.
%Hierbei ist vor allem der Vergleich zwischen Rust und C interessant, da einige von Rusts primären Eigenschaften die
%Risiken der C-Programmierung beseitigen sollen.

%\subsection{Division durch 0}

%Dividiert man in C einen Wert durch die Zahl 0, kann es zu undefiniertem Verhalten führen, welches auf jeden Fall unerwünscht
%ist. Versucht man dies in Rust, so bricht das Programm sofort ab, indem die "`panic\char`_fmt"'-Funktion aufgerufen wird und es
%kann nicht zu undefiniertem Verhalten kommen.

%\subsection{Pufferüberlauf}

%Ein weiterer Fall, der in C zu undefiniertem Verhalten führt, sind Pufferüberläufe. Diese geschehen, wenn man beispielsweise
%in einem Array der Größe n versucht, auf das n+1te Element zuzugreifen. Wie bereits im letzten Vergleich kann dies in 
%Rust nicht geschehen, da das Programm mit einem Aufruf der "`panic\char`_fmt"'-Funktion die Ausführung beendet.

%\subsection{Nicht Initialisierte Variablen}

%In C ist es möglich, uninitialiserte Variablen zu verwenden, dies führt allerdings ebenfalls zu undefiniertem Verhalten.
%In Rust hingegen wird dies bereits vom Compiler verhindert, da er den Gebrauch von uninitialisierten Variablen verbietet.
%Ein Rust-Programm welches also uninitialisierte Variablen verwendet kompiliert also gar nicht und kann so natürlich auch nicht
%zu undefiniertem Verhalten führen.

\subsubsection{Typsystem}

Rust verfügt über ein statisches, typsicheres Typsystem, welches sich an Typsystemen aus funktionalen Sprachen, beispielsweise Haskell, anlehnt\cite{rustWikiDe}. Dies bedeutet dass jede Variable einen eindeutigen Typ besitzt und keinen
anderen Typ annehmen kann. Rust erlaubt es zudem, per Typinferenz die explizite Angabe eines Typen bei der Variablendeklaration zu
vermeiden\cite{rustWikiDe}.

Es gibt wie in den meisten statischen Typsystemen eine Handvoll von primitiven Typen. In Rust gibt es die folgenden\cite{rustTypes}:

\begin{description}
	\item[Vorzeichenlose numerische Typen] u8, u16, u32, u64
	\item[Vorzeichenbehaftete numerische Typen im Zweier-Komplement] i8, i16, i32, i64
	\item[Platformabhängige numerische Typen] usize, isize
	\item[Textuelle Typen] char, str
\end{description}

Zudem gibt es zusätzlich noch generische Konstrukte, nämlich Tupel, Arrays, Slices, Funktionszeiger, Referenzen und Zeiger, welche
auf beliebige Typen anwendbar sind\cite{rustTypes}. Funktionen in Rust erlauben den Gebrauch für generische Typen, welches es
ermöglicht, dass eine Implementierung einer solche Funktion auf mehrere Typen anwendbar ist.

Rust borgt sich Ideen von substrukturellen Typsystemen\cite{linearTypePain}. Standardmäßig verhalten sich Variablen in Rust wie
affine Typen, welches sicherstellt, dass die Variablen höchstens ein mal verwendet werden\cite{substructuralTypesWikiEn}.
Dies wird in der Funktionsweise der "`Move"'-Semantik verdeutlicht\cite{linearTypePain}.
Es ist jedoch auch möglich, durch den Gebrauch der "`Copy"'- oder "`Clone"'-Traits Variablen
beliebig oft zu verwenden\cite{linearTypePain}.
Außerdem ist es möglich, Variablen sich wie lineare Typen verhalten zu lassen, also erzwingen dass diese Variablen mindestens
ein mal verwendet werden\cite{linearTypePain}.

Rusts Objektmodell basiert auf Strukturen, Implementierungen und Traits\cite{rustWikiEn}.
Strukturen (Schlüsselwort struct) ermöglichen die Deklaration von Feldern\cite{rustWikiEn}, 
Traits (Schlüsselwort trait) bieten Polymorphie und Vererbung
\cite{rustWikiEn} und Implementierungen (Schlüsselwort impl) erfüllen eine ähnliche Rolle wie Klassen in
anderen Programmiersprachen\cite{rustWikiEn}.

\subsubsection{Paradigmen}

Unterschiedliche Programmierparadigmen nahmen einen Einfluss auf das Sprachdesign von Rust\cite{rustWikiDe}.
Unter anderem sind Elemente der funktionalen, objektorientierten und nebenläufigen Programmierung anzutreffen\cite{rustWikiDe}.
Dies ermöglicht es unterschiedlichsten Programmierern Rust zu benutzen als auch ein hohes Abstraktionsniveau zu
bieten\cite{rustWikiDe}.

\subsubsection{Fehler- und Ausnahmebehandlung}

In der Programmiersprache Rust werden Ausnahmen behandelt, in dem die "`Option"' oder "`Result"' Aufzählung (enum) als
Rückgabeparameter einer Funktion verwendet werden. Anhand dieser kann man dann prüfen, ob eine Ausnahme beim Funktionsaufruf
aufgetreten ist. Bei unbehandelten Ausnahmen wird für den aktiven Faden (Thread) die "`panic\char`_fmt"'-Funktion aufgerufen.
Bei Fehlern beendet Rust die Ausführung des Programms. 

\subsection{Architektur/Compiler}

Der offizielle Rust Compiler heißt rustc und kann eigenständige Rust-Quelldateien kompilieren. Rust-Quelldateien haben
konventionsgemäß die Dateiendung "`.rs"'. Als Lösung zum Abhängigkeitsmanagement und der Distribution wurde das Werkzeug cargo 
entwickelt. Es ermöglicht es dem Programmierer verwendete Bibliotheken in ein Projekt einzugliedern,
indem diese in einer "`Cargo.toml"' Datei im Hauptverzeichniss
des Projekts angegeben werden. Außerdem unterstützt "`cargo"' mehrere weiter hilfreiche Funktionen zum Testen oder
Distribuieren der entwickelten Software. Kompilierte Software kann als ein sogenanntes "`Crate"' bei der
von den Rust entwickelten Platform "`crates.io"' mithilfe von cargo hochgeladen werden.

Rustc und cargo ermöglichen das Kompilieren für unterschiedliche Zielarchitekturen mithilfe der "`-{}-target"'-Option.

Um den Gebrauch von unterschiedlichen rustc und cargo Versionen zu vereinfachen, wurde das Werkzeug rustup entwickelt. Dieses
Hilfsprogramm ermöglicht es unterschiedliche Varianten des Rust-Compilers zu installieren und bei Belieben zu wechseln.
Außerdem erleichtert es die Kompilierung für anderer Zielarchitekturen, indem es für unterstützte Architekturen eine
vorkompilierte Standardbibliothek herunterladen kann.

Als Compiler-Backend wird LLVM verwendet. Durch diese wird Rust vor der Übersetzung zu Maschinenbefehlen in die Zwischensprache
LLVM-IR übersetzt. Dadurch ist es möglich, Rust-Code auf allen von LLVM unterstützen Rechnerarchitekturen laufen zu lassen.


\section{SPARC-V8}

SPARC (\textbf{S}calable \textbf{P}rocessor \textbf{ARC}hitecture) ist eine Mikroprozessorarchitektur, welche von Sun Microsystems und 
seit 2010\cite{sunWikiDe}, nach der Übernahme von Sun Microsystems, von Oracle entwickelt wird\cite{sparcWikiDe}. Sie kommt
kommerziell derzeit größtenteils in Produkten von Oracle zum Einsatz\cite{sparcWikiDe}.

Die aktuelle 32-bit Variante der SPARC-Architektur wird als SPARC-V8 bezeichnet\cite{sparcWikiDe}.
Die Byte-Reihenfolge von SPARC-V8 ist komplett Big-Endian\cite{sparcWikiDe}.

\subsection{LEON}

Die ursprünglich von der European Space Agency (ESA) und anschließend von Aeroflex Gaisler entwickelten LEON-Prozessoren
basieren auf der SPARC-V8 Architektur\cite{leonWikiDe}. 
Der erste LEON Prozessor war das erste vollständige Mikroprozessor-Design welches unter einer
Open-Source Lizenz, in diesem Fall der GNU Lesser General Public License, veröffentlicht wurde\cite{leonWikiDe}.
Die beiden anschließenden Iterationen
der Prozessorfamilie, LEON2 und LEON3 wurden ebenfalls unter Open-Source Lizenzen verfügbar gestellt\cite{leonWikiDe}.
Deren Nachfolger, LEON4, ist jedoch nicht mehr unter einer freien Lizenz verfügbar\cite{leonWikiDe}.

Da die Designs der LEON, LEON2 und LEON3 Prozessoren als frei verfügbare VHDL-Designs\cite{leonWikiDe} zur Verfügung stehen, eignen 
sich diese gut zur Verwendung in angepassten FPGAs oder ASICs\cite{leonWikiDe}.

\section{Invasives Computing}

Invasives Computing ist ein paralleles Programmiermodell, welches es ermöglicht, temporär Ressourcen auf einem Parallelrechner
zu beanspruchen und anschließend wieder freizugeben. Hierbei gibt es drei wesentliche Phasen: die `Invade`, `Infect` und `Retreat` Phasen \cite{invasicWikiOverview}. 

In der "`Invade"' Phase werden zunächst Ressourcen für das laufende Programm reserviert. Welche Ressourcen genau reserviert werden,
werden durch sogenannte "`Constraints"' bestimmt\cite{invasicWikiOverview}.
Anschließend wird in der "`Infect"' Phase die Funktion auf den reservierten Prozessorelementen ausgeführt\cite{invasicWikiOverview}.
Werden die reservierten Ressourcen nicht mehr benötigt, so kann man diese in der "`Retreat' Phase wieder
freigeben\cite{invasicWikiOverview}.

Das Konzept des invasiven Computings wurde von einer Kollaboration von Wissenschaftlern der
Friedrich-Alexander-Universität Erlangen-Nürnberg, dem Karlsruher Institut für Technologie und der 
Technischen Universität München entwickelt\cite{invasicHome}.
Im Rahmen des "`Transregional Collaborative Research Center Invasive Computing"'\cite{invasicHome}
wird die Entwicklung dieses Programmiermodells vorangetrieben.
Fördermittel erhält diese von der Deutschen Forschungsgemeinschaft\cite{invasicHome}.

Für den praktischen Einsatz des invasiven Computings wurde ein Betriebssystem namens IRTSS entwickelt. Dieses ist generell für den
Einsatz auf FPGAs mit LEON Architektur konzipiert, bietet jedoch auch Versionen für die x86-Architektur. Derzeit ist es möglich,
in den Programmiersprachen C, C++ und X10 Programme für den Einsatz mit IRTSS zu schreiben.
