\chapter{Grundlagen}\label{sec:basics}

Im folgenden Kapitel werden die Grundlagen der Programmiersprache Rust, der Rechnerarchitektur SPARC-V8 und des 
invasiven Computing behandelt, welche zum Verständnis dieser Arbeit beitragen.

\section{Rust}

Rust ist eine relativ neue Programmiersprache, welche wie beispielsweise C++ direkte Kontrolle über die
unterliegende Hardware bieten soll. Dies bedeutet in der Praxis, dass diese Sprache nicht von einem Garbage
Collector Gebrauch macht, wie es Sprachen wie zum Beispiel X10 tun. Im Gegensatz zu C++ bietet Rust jedoch
standardmäßig Speichersicherheit und garantieren somit dass Programme keine Speicherfehler beinhalten.
\cite{theRustLanguage}

Rust erfreut sich in der jüngsten Vergangenheit wachsende Beliebtheit bei Programmierern aller Art. So wurde
bei einer Umfrage der Webseite stackoverflow.com Rust im Jahre 2016 als beliebteste Programmiersprache bei 
Entwicklern ermittelt\cite{stackoverflowSurvey}.

Das wohl derzeit prominenteste Projekt, welches Rust verwendet, ist der Servo Web Browser Engine. Dieses Projekt
wurde von Mozilla Research initialisiert, erhält jedoch ebenfalls Beiträge von Freiwilligen
als auch von Unternehmen wie Samsung.
Diese Software soll nach und nach im Mozilla Firefox Webbrowser integriert werden und hierbei eine bessere
Leistung uns Sicherheit als vorhergehende Technologien vorweisen\cite{engineeringServo}.

\subsection{Motivation}

Eine der Kernziele der Rust Programmiersprache ist es, sichere Speicherzugriffe zu gewährleisten, ohne
für diesen Zweck einen Garbage Collector zu verwenden. Fehlerhafte Speicherzugriffe können undefiniertes
Verhalten auslösen, welches ein Sicherheitsrisiko darstellen kann, denn diese Fehler können gezielt ausgenutzt
werden, um Schadcode auszuführen.\cite{engineeringServo}\cite{undefinedBehaviour}

Außerdem soll Rust paralleles Rechnen unterstützen und so möglichst effizient moderne Hardware verwenden.
Hierfür sollen gewisse häufig auftretende Fehler in der Parallelprogrammierung gänzlich entfallen.
\cite{theRustLanguage}

Rust lehnt sich konzeptionell und syntaktisch an C-ähnliche Sprachen an, enthält jedoch auch Konzepte aus der
funktionalen Programmierung. Zusätzlich werden Sprachkonzepte und Abstraktionen geboten, welche
ansonsten zumeist in höheren Programmiersprachen geboten werden. Hierdurch soll der Einstieg für
Programmierer, die zuvor keine oder nur wenige Erfahrungen mit Systemsprachen gemacht haben, erleichtert werden.
\cite{engineeringServo}

Diese zusätzliche Sicherheiten und Nutzerfreundlichkeiten sollen jedoch keine Laufzeitkonsequenzen mit sich ziehen,
denn Rust soll in dieser Hinsicht ähnliche Ergebnisse wie andere Systemsprachen, beispielsweise C oder C++,
aufweisen. Außerdem soll Rust es vereinfachen, mehrere Programmiersprachen miteinander zu verwenden. Es soll
also möglich sein, Code aus anderen Sprachen aus einem Rust Kontext zu verwenden als auch umgekehrt.\cite{rustBook}


\subsection{Das Typsystem}

Das signifikanteste Alleinstellungsmerkmal der Programmiersprache Rust ist ihr Typsystem. Dieses ermöglicht es
erst, die versprochenen Sicherheitsgarantien ohne zusätzliche Konstrukte wie einen Garbage
Collector zu realisieren.\cite{rustBook}

\subsubsection{Ownership, Move-Semantik und Borrowing}

Das Typsystem integriert das Konzept der \textit{Ownership (engl. Besitz)} ein.
Dies ist die zentrale Besonderheit von Rusts Typsystem.
Der Grundgedanke hierhinter ist es, dass der Zugriff auf eine Speicherregion einer Variable exklusiv
zur Verfügung gestellt wird. Diese Variable wird auch\textit{Owner (engl. Besitzer)} genannt.
Zu jedem Zeitpunkt darf die Speicherregion nur einen \textit{Owner} haben.
Sobald dieser \textit{Owner} den Geltungsbereich verlässt, wird die zugehörige Speicherregion freigegeben.
Dies ist der Mechanismus, der es in Rust erlaubt, Speicher ohne manuelle Befreiung oder Nutzung eine
Garbage Collectors zu verwalten.\cite{rustBook}

Die \textit{Ownership} einer Speicherregion kann mithilfe der \textit{Move}-Semantik den Besitzer wechseln.
Die kann bei Funktionsaufrufen oder auch bei einer Zuweisung geschehen. Beispiele hierfür sind in Abbildung
\ref{code:move_semantics} zu sehen.\cite{rustBook}

\begin{lstlisting}[float,caption={Beispieldarstellung der \textit{Move}-Semantik},label=code:move_semantics]
let x = String::from("hello");;
// Owner: x

let y = x;
// Owner: y
// x ist nun ungueltig

let z = f(y) 
// Owner: -
// Ownership wurde an f uebergeben,
// da f aber bereits den Geltungsbereich verlassen hat
// ist der Speicherbereich nun befreit.
// y ist nun ungueltig
\end{lstlisting}\cite{rustBook}

Zusätzlich zur \textit{Move}-Semantik können in Rust Referenzen zu Variablen verwendet werden. Dies wird im Kontext
von Rust häufig als \textit{borrowing (engl. ausleihen)} bezeichnet. Verwendet man eine Referenz auf eine Variable,
ist der \textit{Owner} des Speicherbereichs weiterhin die originale Variable. Es gibt zwei unterschiedliche
Typen von Referenzen, veränderliche und unveränderliche Referenzen. Standardmäßig werden in Rust unveränderliche
Referenzen verwendet. Diese erlauben es nicht, den Wert des Speicherbereichs zu verändern, sondern nur auszulesen.
Es gibt keine Limitierung bei der Anzahl unveränderlicher Referenzen eine Variable besitzen kann. Im Gegensatz
hierzu kann nur eine veränderliche Referenz auf die Variable existieren. Dies ermöglicht es, bereits zur
Compile-Zeit gewisse Wettlaufsituationen, \textit{Race Conditions}, in der Parallelprogrammierung auszuschließen. 
\cite{rustBook}

\subsubsection{Strukturen, Implementierungen und Traits}

Zum Erstellen von benutzerdefinierten Typen bietet Rust Strukturen (\texttt{\textsc{\textbf{struct}}}),
Implementierungen (\texttt{\textsc{\textbf{impl}}}) und Traits (\texttt{\textsc{\textbf{trait}}}).

Strukturen in Rust spezifizieren benutzerdefinierte Datentypen, welche verwandte Daten vereinen. Das Konzept
ähnelt den Strukturen in C. Anders wie in C kann man jedoch mithilfe von Implementierungen Methoden und assozierte
Funktionen für diese Strukturen definieren.
Diese Möglichkeit erlaubt es eine objektorientierte Herangehensweise in Rust zu verwenden.
Implementierungen erlauben das Definieren von Methoden, welche auf einer initiierten Struktur aufgerufen werden
und eine Referenz auf \texttt{\textsc{\textbf{self}}}, also der Struktur selbst, als Parameter entgegennehmen.
Zusätzlich können Funktionen definiert werden, welche keinen solchen Parameter entgegennehmen und somit auch mit
nicht initiierten Strukturen verwendet werden kann. Dies ähnelt statischen Methoden in objektorientierten
Sprachen.\cite{rustBook}

Traits sind ein Sprachkonstrukt in Rust, welches das Verhalten von Typen abstrakt definieren können. Sie ähneln sich
hierbei Schnittstellen aus anderen Programmiersprachen. Zusätzlich zur benutzerdefinierten Spezifikation
solcher Schnittstellen-ähnlichen Konstrukte bietet Rust vordefinierte Traits, welche das Verhalten der Typen
bezüglich \textit{Ownership} und \textit{Move}-Semantik beeinflussen.\cite{rustBook}

Zum einen existiert das \textit{Drop}-Trait. Dieses Trait erlaubt es, das Verhalten eines Typen beim Verlassenen des
Geltungsbereichs zu beeinflussen. In der \textit{drop}-Methode des Traits wird es ermöglicht, einen Destruktor
für den Typ zu implementieren. Dieser kann aus unterschiedlichen Gründen benötigt oder hilfreich sein.
Beispielsweise kann man diesen verwenden, um einen Referenzzähler zu dekrementieren, unbenutzte Netzwerkverbindungen
zu trennen oder anderweitige Ressourcen freizugeben.\cite{rustBook}

Außerdem gibt es die \textit{Copy}-Traits, welche es ermöglichen, anstelle der \textit{Move}-Semantik die
\textit{Copy}-Semantik zu verwenden. Jedes mal, wenn ein Speicherbereich im Kontext der \textit{Move}-Sematik
den \textit{Owner} wechseln würde, wird
stattdessen eine bitweise Kopie der Daten erstellt. Primitive Datentypen wie \texttt{\textsc{\textbf{i32}}}
verhalten sich standardmäßig genau so. Das \textit{Copy}-Trait kann jedoch nicht auf jeden Typ
angewandt werden. Insbesondere kann das \textit{Drop}-Trait nicht gleichzeitig auf diesen Typ angewandt werden,
da diese beim Verlassen des Geltungsbereichs einen Einfluss außerhalb ihres Speicherbereich haben können. \cite{rustBook}\cite{rustDocCopy}

\subsubsection{Affine und Lineare Typen}

TODO

\subsection{Fehler- und Ausnahmebehandlung}

In der Programmiersprache Rust werden Ausnahmen behandelt,
in dem eine \textit{Option} oder \textit{Result} Aufzählung als
Rückgabeparameter einer Funktion verwendet wird.
Anhand dieser lässt es sich prüfen, ob eine Ausnahme beim Funktionsaufruf
aufgetreten ist. Bei unbehandelten Ausnahmen wird für den aktiven Faden die
\texttt{\textsc{\textbf{panic\char`_fmt"'}}}-Funktion aufgerufen.
Bei Fehlern beendet Rust die Ausführung des Programms.

\subsection{Architektur/Compiler}

Der offizielle Rust Compiler heißt \texttt{\textsc{\textbf{rustc}}} und kann eigenständige Rust-Quelldateien
kompilieren. Rust-Quelldateien haben per Konvention die Dateiendung \texttt{\textsc{\textbf{.rs}}}.\cite{rustBook}

Als Lösung zum Abhängigkeitsmanagement und der Distribution wurde das Werkzeug \texttt{\textsc{\textbf{cargo}}} 
entwickelt. Es ermöglicht es dem Programmierer, verwendete Bibliotheken in ein Projekt einzugliedern,
indem diese in einer \texttt{\textsc{\textbf{Cargo.toml}}}-Konfigurationsdatei im Hauptverzeichnis
des Projekts angegeben werden. Hierbei ist es möglich, Bibliotheken von der zentralen \textit{crates.io}
Platform automatisch herunterladen zu lassen oder einen lokalen Dateipfad zu einer solchen
Bibliothek anzugeben.
Außerdem unterstützt \texttt{\textsc{\textbf{cargo}}} mehrere weiter hilfreiche Funktionen zum Testen oder
Distribuieren der entwickelten Software. Kompilierte Software kann als ein sogenanntes \textit{Crate} bei
\textit{crates.io} hochgeladen werden.\cite{rustBook}

Um den Gebrauch von unterschiedlichen \texttt{\textsc{\textbf{rustc}}} und \texttt{\textsc{\textbf{cargo}}} Versionen 
zu vereinfachen, wurde das Werkzeug \texttt{\textsc{\textbf{rustup}}} entwickelt. Dieses
Hilfsprogramm ermöglicht es unterschiedliche Varianten des Rust-Compilers zu installieren und bei Belieben zu
wechseln. Es bietet auch die Funktionalität, die benötigten Bibliotheken für unterstützte Architekturen
herunterzuladen um Programme für andere Zielarchitekturen zu kompilieren.

Sowohl \texttt{\textsc{\textbf{rustc}}} als auch \texttt{\textsc{\textbf{cargo}}} ermöglichen das Kompilieren für
unterschiedliche Zielarchitekturen mithilfe der \texttt{\textsc{\textbf{rustc}}} und
\texttt{\textsc{\textbf{-{}-target}}}-Option. Als Compiler-Backend wird LLVM verwendet.
Rust-Code wird also vor der Übersetzung zu Maschinenbefehlen in die Zwischensprache
LLVM-IR übersetzt und erst anschließend weiterverarbeitet. Somit ist es möglich, Rust-Programme für alle von LLVM
unterstützen Rechnerarchitekturen zu kompilieren.




%\section{Sicherheit}

%Im folgenden wird die Sicherheit bezüglich undefiniertem Verhalten als Folge von fehlerhaften Speicherzugriffen analysiert.
%Hierbei ist vor allem der Vergleich zwischen Rust und C interessant, da einige von Rusts primären Eigenschaften die
%Risiken der C-Programmierung beseitigen sollen.

%\subsection{Division durch 0}

%Dividiert man in C einen Wert durch die Zahl 0, kann es zu undefiniertem Verhalten führen, welches auf jeden Fall unerwünscht
%ist. Versucht man dies in Rust, so bricht das Programm sofort ab, indem die "`panic\char`_fmt"'-Funktion aufgerufen wird und es
%kann nicht zu undefiniertem Verhalten kommen.

%\subsection{Pufferüberlauf}

%Ein weiterer Fall, der in C zu undefiniertem Verhalten führt, sind Pufferüberläufe. Diese geschehen, wenn man beispielsweise
%in einem Array der Größe n versucht, auf das n+1te Element zuzugreifen. Wie bereits im letzten Vergleich kann dies in 
%Rust nicht geschehen, da das Programm mit einem Aufruf der "`panic\char`_fmt"'-Funktion die Ausführung beendet.

%\subsection{Nicht Initialisierte Variablen}

%In C ist es möglich, uninitialiserte Variablen zu verwenden, dies führt allerdings ebenfalls zu undefiniertem Verhalten.
%In Rust hingegen wird dies bereits vom Compiler verhindert, da er den Gebrauch von uninitialisierten Variablen verbietet.
%Ein Rust-Programm welches also uninitialisierte Variablen verwendet kompiliert also gar nicht und kann so natürlich auch nicht
%zu undefiniertem Verhalten führen.




\section{SPARC und SPARC-V8}

SPARC (\textbf{S}calable \textbf{P}rocessor \textbf{ARC}hitecture) ist eine Rechnerarchitektur, welche auf das
RISC (Reduced Instruction Set Computing) Konzept aufbaut. Eines der Ziele der SPARC Architektur ist es, skalierbar
zu sein und so in unterschiedlichsten Umgebungen zum Einsatz zu kommen. So können SPARC Prozessoren in
Mikrocontrollern bis hin zu Supercomputern verwendet werden. Die Architektur wird an unterschiedliche
Halbleiter-Unternehmen lizensiert, mit dem Ziel durch konkurrierende Kräfte Innovation bezüglich Leistung oder
Kosten zu fördern.\cite{sparc}

SPARC-V8 ist eine auf SPARC basierende Architektur. Es handelt sich hierbei um eine Allzweckarchitektur mit einem
32-bit breiten Datenpfad.\cite{sparcv8Eval}

\subsection{LEON}

Die ursprünglich von der European Space Agency (ESA) und anschließend von Gaisler Research entwickelten
LEON-Prozessoren basieren auf der SPARC-V8 Architektur.
Das Hauptziel der LEON-Prozessoren war es, fehlertolerante Nachfolger zu älteren SPARC-V7-basierten
Prozessoren, die zu dem Zeitpunkt bei der ESA Verwendung fanden, zu bieten.\cite{gaislerLeon}
Es handelt sich bei ihnen um stark konfigurierbare
Implementierungen der SPARC-V8 Architektur in der Hardwarebeschreibungssprache
VHDL (Very High Speed Integrated Circuit Hardware Description Language).
Unterschiedliche Iterationen dieser Prozessorfamilie sind unter Open-Source Lizenzen als VHDL-Designs verfügbar.
So wurden die VHDL-Designs des LEON2 Prozessors unter der GNU LGPL Lizenz veröffentlicht.\cite{sparcv8Eval}
Auch das Design des LEON3 Prozessors ist unter einer Open-Source Lizenz verfügbar\cite{}.

Die Kombination von stark konfigurierbaren Designs und der Open-Source Lizenz ermöglicht den Gebrauch der
LEON VHDL Designs in domänenspezifischen, angepassten ASICs (Application-Specific Integrated Circuit),
FPGAs (Field Programmable Gate Array) oder SOCs (System On Chip). Daher eignet sich die LEON Prozessorfamilie
auch zum Einsatz im invasiven Computing, um deren neuartigen Konzepte möglichst effizient auszunutzen.
\cite{sparcv8Eval}

\section{Invasives Computing}

Invasives Computing beschreibt die Möglichkeit eines Programms auf einem Parallelrechner,
dynamisch Hardwareressourcen zu reservieren, nutzen und anschließend wieder freizugeben.\cite{octopos}

Die drei fundamentalen Phasen des invasiven Computing sind die \textit{\textbf{Invade}}, \textit{\textbf{Infect}}
und \textit{\textbf{Retreat}} Phasen. In der \textit{Invade} Phase werden zunächst die gewünschten
Hardwareressourcen angefordert und anschließend reserviert. Diese Menge an Hardwareressourcen kann dann mithilfe
eines \textit{Claims} verwaltet werden. Die zu reservierenden Ressourcen werden mithilfe von \textit{Constraints}
angegeben.
Sind die Ressourcen reserviert, kann die \textit{Infect}
Phase beginnen. In dieser werden Ausführungsfaden erstellt,
welche auf den reservierten Hardwareressourcen ausgeführt werden. Im Kontext des invasiven Computing wird ein solcher
Faden als \textit{inasive-let} oder abgekürzt als \text{i-let} bezeichnet\cite{invasiveCommonTerms}.
Benötigt das Programm die reservierten Ressourcen nicht mehr, können diese in der \textit{Retreat} Phade wieder
freigegeben werden.\cite{octopos}

Für den praktischen Einsatz des invasiven Computings wurde ein Betriebssystem namens \textit{OctoPOS} entwickelt. 
Dieses unterstützt die \textit{Invade}, \textit{Infect} und \textit{Retreat} Phasen auf der Systemebene.
Zusätzlich hierzu existiert das \textit{Invasive Run-Time Support System (IRTSS)}. Diese Middleware
\cite{invasiveRISC} fungiert als eine Hardware-Abstraktionsschicht und als
Ressourcenverwalter \cite{invasiveManyCore}.
\textit{OctoPOS} und \textit{IRTSS} bieten so eine Platform für das invasive Programmieren.\cite{octopos}

Um das Konzept des invasiven Computing möglichst effizient auszunutzen, wurden speziell an das invasive Computing
angepasste Hardware entwickelt, deren Prozessorkerne auf dem Design des LEON3 Prozessors basieren.
Diese Hardware unterstützen gewisse invasive Grundfunktionen und entlastet somit das Betriebssystem und das IRTSS.
\cite{invasiveArrays}

Zurzeit unterstützen OctoPOS und IRTSS den Einsatz der Programmiersprachen C, C++ und X10.