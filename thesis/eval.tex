\chapter{Evaluation}\label{sec:eval}

%Dies kann in Benchmarks zumeist auch bestätigt werden\cite{rustVsCBenchmark}. 
%Benchmarks, welche Rust mit
%höheren Programmiersprachen wie Java\cite{rustVsJavaBenchmark} oder Python\cite{rustVsPythonBenchmark} vergleichen,
%weisen meist eine bessere Leistung von Rust auf.

Im Folgenden wird der Gebrauch von Rust im Zusammenhang mit dem invasiven Computing evaluiert. Hierbei
wird vor allem mit den bereits unterstützten Sprachen C und X10 verglichen.

Jedes der folgenden Programme wurde auf der folgenden Hardware/Software Konfiguration kompiliert und ausgeführt:

\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{ll}
			\midrule
			CPU & Intel Core i5-5200U @ 2.2GHZ x 2 \\
			Hauptspeicher & 8GB \\
			Betriebssystem & Ubuntu 16.04.3 LTS \\
			Linux Kernel & Version 4.4.0-97-generic \\
			gcc & 6.3.0 \\
			IRTSS & 2017-06-07-nightly \\
			rustc & 1.19.0-nightly \\
			JDK & openjdk 1.8.0\char`_131 \\
			octorust & Version 1.0.0 \\
			x10i & Commit 31183335a89917f489046da746c5181174a7bdb3 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		Dies ist die Hard- und Software Konfiguration des Rechners,
		auf dem die nachfolgenden Programme kompiliert und ausgeführt wurden.
	}
	\label{fig:specs_table}
\end{figure}

Für jedes betrachtete Programm wurden je zwei Versionen pro Programmiersprache betrachtet.
Zum einen mit Compiler-Optimierungen,
zum anderen ohne. Bei Messungen der Ausführungszeit wurde die Wall-Clock-Time in Sekunden als Messwert verwendet.
Jedes Programm, dessen Laufzeit
überprüft wird, wird mithilfe des "`temci"'-Benchmarkprogramms fünfzig mal ausgeführt.

Um die statistische Relevanz der Ergebnisse zu evaluieren, wurden zu jeder Messung der Laufzeit
das arithmetische Mittel (Abbildung \ref{formula:mean}),
der Median (Abbildung \ref{formula:median}),
die Median Absolute Deviation (Abbildung \ref{formula:mad}),
die korrigierte empirische Standardabweichung (Abbildung \ref{formula:std_deviation}) und
den zugehörigen empirischen Variationskoeffizienten (Abbildung \ref{formula:variation_coefficient}) berechnet.

\begin{figure}
	\caption{Das Arithmetische Mittel}
	\begin{equation}
		\label{formula:mean}
		\bar{x} = \frac{1}{n} \sum_{i=1}^n{x_i}
	\end{equation}
\end{figure}

\begin{figure}
	\caption{Der Median}
	\begin{equation}
		\label{formula:median}
		\tilde{x} =
		\begin{cases}
			x_{\frac{n + 1}{2}} & n \text{ ungerade} \\
			\frac{1}{2}(x_\frac{n}{2} + x_{\frac{n}{2} + 1}) & n \text{ gerade} \\
		\end{cases}
	\end{equation}
\end{figure}

\begin{figure}
	\caption{Die empirische Standardabweichung}
	\begin{equation}
		\label{formula:std_deviation}
		s = \sqrt{\frac{1}{n - 1}}
	\end{equation}
\end{figure}

\begin{figure}
	\caption{Der empirische Variationskoeffizient}
	\begin{equation}
		\label{formula:variation_coefficient}
		s = \frac{s}{\bar{x}}
	\end{equation}
\end{figure}

\begin{figure}
	\caption{Die Median Absolute Deviation}
	\begin{equation}
		\label{formula:mad}
		E(n) = \frac{1}{n} \sum_{i=1}^n{|x_i - \tilde{x}|}
	\end{equation}
\end{figure}




\section{Kompilierungsdauer und Dateigröße}\label{sec:compile_time_filesize}

Zu Beginn werden die Kompilierungsdauer und die Dateigröße bei Gebrauch der einzelnen Programmiersprachen
verglichen. Diese Werte wurden für ein simples Programm betrachtet, welches lediglich die Ausführung startet und
anschließend sofort wieder beendet.

\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{lrrrrr}
			\toprule
			Sprache    & $\bar{x}$ & $\title{x}$ & $s$ & $V$ & $MAD$ \\
			\midrule
			C          &  0.5564 & 0.5600 & 0.0138 & 2.4829\% & 0.0100 \\
			C (opt)    &  0.5586 & 0.5600 & 0.0134 & 2.3993\% & 0.0100 \\
			Rust       &  0.8174 & 0.8200 & 0.0164 & 2.0051\% & 0.0100 \\
			Rust (opt) &  0.8116 & 0.8100 & 0.0136 & 1.6765\% & 0.0100 \\
			X10        & 82.8640 & 83.075 & 1.3321 & 1.6076\% & 1.1600 \\
			X10 (opt)  &  0      & 0      & 0      & 0      & 0        \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		Diese Tabelle stellt die Messergebnisse der Kompilierungsdauer des startup-Benchmarks dar. Die Werte
		des Mittel und des Median sind in Sekunden angegeben.
		\textcolor{red}{TODO X10 opt Werte}
	}
	\label{fig:compile_table}
\end{figure}

\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{lrrrr}
			\toprule
			Sprache & Dateigröße \\
			\midrule
			C          & 0 & 0 \\
			C (opt)    & 0 & 0 \\
			Rust       & 0 & 0 \\
			Rust (opt) & 0 & 0 \\
			X10        & 0 & 0 \\
			X10 (opt)  & 0 & 0 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		Diese Tabelle stellt die Messergebnisse der Dateigrößen des startup-Benchmarks dar. Die Messwerte sind in
		der Anzahl Bytes, welche die ausführbare Datei ausmachen, angegeben.
		\textcolor{red}{TODO Werte}
	}
	\label{fig:filesize_table}
\end{figure}

Anhand der Ergebnisse in Tabelle \ref{fig:compile_table} kann man feststellen,
dass die Kompilierungsdauer bei Rust oder C Programmen im Vergleich zu
X10 Programmen gering sind. X10 Programme benötigen im Schnitt über 80 Sekunden länger um kompiliert zu werden.
Außerdem sind die Dateigrößen der X10 Programme größer als die der Rust und C Programme,
jedoch nicht im selben Maße wie die Kompilierungsdauer.

\textcolor{red}{TODO Auf Statistische Mittel eingehen}

\section{Laufzeitverhalten}

Um die erreichbare Leistung der Programmiersprachen zu vergleichen,
wurden im Folgenden unterschiedliche Programme entwickelt.
Diese Programme wurden soweit möglich in allen Programmiersprachen einheitlich implementiert und ermöglichen so,
das Laufzeitverhalten der Programmiersprachen zu vergleichen.

\subsection{Vergleich der Anlaufzeit}

Es wird zunächst überprüft, wie lange ein Programm,
welches in einer zu betrachtenden Programmiersprachen geschrieben wurde,
benötigt, um die Ausführung zu starten und anschließend sofort wieder zu beenden.
Es wurde das exakt selbe Programm verwendet, welches in Kapitel \ref{sec:compile_time_filesize} zur Messung
der Kompilierungsdauer und Dateigröße verwendet wurde.

\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{lrrrrr}
			\toprule
			Sprache    & $\bar{x}$ & $\title{x}$ & $s$ & $V$ & $MAD$ \\
			\midrule
			C          & 0.3916 & 0.3800 & 0.0214 & 5.4687\% & 0.0100 \\
			C (opt)    & 0.3900 & 0.3800 & 0.0208 & 5.3334\% & 0.0100 \\
			Rust       & 0.3820 & 0.3800 & 0.0139 & 3.6258\% & 0.0100 \\
			Rust (opt) & 0.4026 & 0.3800 & 0.0459 & 11.408\% & 0.0100 \\
			X10        & 1.7738 & 1.7800 & 0.0255 & 1.4357\% & 0.0150 \\
			X10 (opt)  & 1.7506 & 1.7500 & 0.0234 & 1.3380\% & 0.0200 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		Diese Tabelle stellt die Messergebnisse der Laufzeit des startup-Benchmarks dar.
		Dieser Benchmark simuliert das Starten und sofortige Schließen eines Programms.
	}
	\label{fig:startup_table}
\end{figure}

Anhand der Werte in Tabelle \ref{fig:startup_table} kann man prinzipiell erkennen,
dass die Anlaufzeiten von C und Rust sich sehr nahe sind, während X10 hierfür im Schnitt 2 Sekundenlänger benötigt.
Auch wenn man die Varianz der Werte in Betracht zieht, bleibt diese Diskrepanz bestehen.


\subsection{Berechnen von Primzahlen}\label{sec:primes_calc}

Um die Rechenleistung der verschiedenen Programmiersprachen bei einem intensiveren Problem zu vergleichen, wurden
Programme geschrieben, welche Primzahlen berechnen. Hierbei wurden zwei unterschiedliche Ansätze verwendet: zum einen
eine naive Berechnung, welche jede Zahl individuell auf Teilbarkeit mit kleineren Zahlen prüft und andererseits
das Sieb von Eratosthenes, eine effiziente Methode zum Berechnen von Primzahlen.

Im Falle des Siebs von Eratosthenes kann Rust in diesem Kontext keine Quadratwurzeloperation durchführen,
da diese die Standardbibliothek benötigen. Daher wurden in allen Sprachen anstelle einer Quadratwurzelfunktion
feste Zahlen verwendet, um den Vergleich zwischen den Sprachen gerecht zu gestalten.
Da jedoch nur eine Quadratwurzeloperation für das Sieb des Eratosthenes
benötigt wird, wäre dies ohnehin aller Wahrscheinlichkeit nach kein entscheidender Faktor bei der Laufzeitmessung.


\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{lrrrrr}
			\toprule
			Sprache    & $\bar{x}$ & $\title{x}$ & $s$ & $V$ & $MAD$ \\
			\midrule
			C          & 4.2094  & 4.2000  & 0.0219 & 0.5201\% & 0.0100 \\
			C (opt)    & 4.2202  & 4.2300  & 0.0277 & 0.6572\% & 0.0150 \\
			Rust       & 61.6462 & 61.6050 & 0.2849 & 0.4621\% & 0.1200 \\
			Rust (opt) & 4.9692  & 4.9650  & 0.0319 & 0.6413\% & 0.0250 \\
			X10        & 10.583  & 10.550  & 0.1368 & 1.2923\% & 0.0200 \\
			X10 (opt)  & 5.9694  & 5.9700  & 0.0719 & 1.2039\% & 0.0300 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		Diese Tabelle stellt die Ergebnisse des naive-primes-Benchmarks dar.
		Dieser Benchmark überprüft die ersten 50000 natürlichen Zahlen darauf,
		ob es sich bei ihnen um Primzahlen handelt,
		indem er für jede Zahl individuell alle kleinere Zahlen auf Teilbarkeit prüft.
	}
	\label{fig:primes_naive_table}
\end{figure}

\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{lrrrrr}
			\toprule
			Sprache    & $\bar{x}$ & $\title{x}$ & $s$ & $V$ & $MAD$ \\
			\midrule
			C          & 0.5626 & 0.5600 & 0.0191 & 3.4031\% & 0.0100 \\
			C (opt)    & 0.5620 & 0.5600 & 0.0199 & 3.5405\% & 0.0100 \\
			Rust       & 0.8362 & 0.8300 & 0.0138 & 1.6544\% & 0.0100 \\
			Rust (opt) & 0.4984 & 0.4900 & 0.0210 & 4.2196\% & 0.0100 \\
			X10        & 2.3508 & 2.3400 & 0.0347 & 1.4782\% & 0.0200 \\
			X10 (opt)  & 1.9892 & 1.9900 & 0.0274 & 1.3771\% & 0.0200 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		Diese Tabelle stellt die Ergebnisse des eratosthenes-primes-Benchmarks dar.
		Dieser Benchmark überprüft mithilfe des Siebs von Eratosthenes die ersten 1690000 natürlichen Zahlen darauf,
		ob es sich bei ihnen um Primzahlen handelt.
	}
	\label{fig:primes_eratosthenes_table}
\end{figure}

Mit den Werten in den Tabellen \ref{fig:primes_naive_table} und \ref{fig:primes_eratosthenes_table} lassen sich keine
eindeutigen Aussage darüber treffen, welche der Programmiersprachen die Aufgabe am effizientesten
absolviert hat, vorausgesetzt, es werden die Versionen mit Compiler-Optimierungen betrachtet. Es existiert
jedoch eine Tendenz, dass C und Rust eine bessere Laufzeit als X10 aufweisen.
Allerdings muss dabei auch die längere Anlaufzeit von X10 Programmen beachtet werden.
Zieht man diese ab, kann X10 ohne Weiteres mit der Leistung von C und Rust mithalten.

Werden allerdings die Versionen ohne Compiler-Optimierungen betrachtet, kann es deutliche Unterschiede zwischen den
Sprachen geben. In Tabelle \ref{fig:primes_naive_table} ist beispielsweise zu erkennen, dass die unoptimierte
Version des Rust Programms weitaus länger Zeit zur Ausführung benötigt als jegliche anderen betrachteten
Konfigurationen. Auch im Falle von X10 verschlechtert sich das Laufzeitverhalten, wenn auch nicht so
sehr wie im Falle von Rust.

\subsection{Paralleles Berechnen von Primzahlen}

Um auch die invasiven Aspekte der Sprachen zu evaluieren, wurden X10, C und Rust Programme geschrieben,
welche Primzahlen in einer parallelen Art und Weise berechnen.
Hierfür wird die Menge an Zahlen, welche überprüft werden sollen,
ob es sich bei ihnen um Primzahlen handelt, gleichermaßen in Partitionen getrennt.
Die Anzahl und Größe der Partitionen hängen hierbei von der Anzahl an verfügbaren Rechenelementen ab.
Jedes der Rechenelemente berechnet anschließend die ihm zugewiesene Menge an Zahlen naiv,
indem die Zahl mit jeder kleineren Zahl auf Teilbarkeit geprüft wird.

\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{lrrrr}
			\toprule
			Sprache & $\bar{x}$ & $\title{x}$ & $s$ & $V$ & $MAD$ \\
			\midrule
			C          & 30.6064 & 30.590 & 0.6380 & 2.0844\% & 0.6400 \\
			C (opt)    & 30.4666 & 30.075 & 0.6262 & 2.0554\% & 0.1750 \\
			Rust       & 476.9242 & 475.895 & 3.6647 & 0.7684\% & 1.3450 \\
			Rust (opt) & 37.6212 & 37.330 & 0.6651 & 1.7679\% & 0.0200 \\
			X10        & 67.9618 & 67.405 & 1.1505 & 1.6929\% & 0.0750 \\
			X10 (opt)  & 31.4584 & 31.305 & 0.4181 & 1.3290\% & 0.0450 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		Diese Tabelle stellt die Laufzeitergebnisse des sequentiellen Ergebnisses des parallel-primes-Benchmarks dar,
		es wurde also die zu verwendende Anzahl an Rechenelementen auf 1 gesetzt.
		Dieser Benchmark überprüft die ersten 500000 natürlichen Zahlen darauf, ob es sich bei ihnen um Primzahlen
		\textcolor{red}{TODO Werte} handelt.
	}
	\label{fig:primes_parallel_one_table}
\end{figure}

\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{lrrrr}
			\toprule
			Sprache & $\bar{x}$ & $\title{x}$ & $s$ & $V$ & $MAD$ \\
			\midrule
			C          & 13.8136 & 13.780 & 0.0935 & 0.6772\% & 0.0200 \\
			C (opt)    & 13.7898 & 13.780 & 0.0912 & 0.6612\% & 0.0200 \\
			Rust       & 242.656 & 242.48 & 0.7602 & 0.3133\% & 0.1200 \\
			Rust (opt) & 17.883 & 17.870 & 0.0862 & 0.4823\% & 0.0300 \\
			X10        & 46.3264 & 46.380 & 0.2348 & 0.5069\% & 0.2100 \\
			X10 (opt)  & 16.8028 & 16.760 & 0.1181 & 0.7026\% & 0.0750 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		Diese Tabelle stellt die Laufzeitergebnisse des parallel-primes-Benchmarks dar,
		wenn 8 Rechenelemente verwendet werden.
		Dieser Benchmark überprüft die ersten 500000 natürlichen Zahlen darauf,
		ob es sich bei ihnen um Primzahlen handelt.
		\textcolor{red}{TODO Werte}
	}
	\label{fig:primes_parallel_eight_table}
\end{figure}

Der Vergleich der Werte in Tabelle \ref{fig:primes_parallel_one_table} und \ref{fig:primes_parallel_eight_table} 
lässt nochmals, wie bereits in Kapitel \ref{sec:primes_calc}, darauf schließen, dass der Einsatz einer bestimmten
Programmiersprache in diesem Fall nicht signifikant die Laufzeit beeinflusst. Es zeichnet sich jedoch ab, dass
Rust sich bei dieser naiven Berechnung von Primzahlen hinsichtlich der Ausführungszeit schlechter verhält als
die anderen beiden Sprachen.

\textcolor{red}{TODO Auf Statistische Mittel eingehen}

Zur Bewertung von parallelen Algorithmen verwendet man unter Anderem die Werte des Speedup und der Effizienz.
Den relativen Speedup eines parallelen Programms berechnet man mit der Formel \ref{formula:speedup} und die
Effizienz mit der Formel \ref{formula:effizienz}. $S(n)$ bezeichnet hierbei den Speedup, $E(n)$ die Effizienz
und $T(x)$ die Ausführungszeit mit x Prozessoren.

\begin{equation}
	\label{formula:speedup}
	S(n) = \frac{T(1)}{T(n)}
\end{equation}


\begin{equation}
	\label{formula:effizienz}
	E(n) = \frac{S(n)}{n}
\end{equation}

Mit den Werten aus Tabelle \ref{fig:primes_parallel_one_table} und \ref{fig:primes_parallel_eight_table} und diesen
Formeln kann man nun auch den Speedup und die Effizienz für das implementierte Programm für die unterschiedlichen
Varianten berechnen.

\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{lrrrr}
			\toprule
			Sprache & $S_\bar{x}(8)$ & $S_\tilde{x}(8)$ &  $E_\bar{x}(8)$ & $E_\tilde{x}(8)$ \\
			\midrule
			C          & 2.2157 & 2.2199 & 0.2770 & 0.2775 \\
			C (opt)    & 2.2094 & 2.1825 & 0.2762 & 0.2728 \\
			Rust       & 1.9654 & 1.9626 & 0.2457 & 0.2453 \\
			Rust (opt) & 2.1037 & 2.0890 & 0.2630 & 0.2611 \\
			X10        & 1.4670 & 1.4533 & 0.1834 & 0.1817 \\
			X10 (opt)  & 1.8722 & 1.8678 & 0.2340 & 0.2335 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		In dieser Tabelle werden die berechneten Werte für den Speedup und die Effizienz des parallel-primes-Benchmarks
		veranschaulicht.
		\textcolor{red}{TODO Werte}
	}
	\label{fig:primes_parallel_speedup_efficiency_table}
\end{figure}

Betrachtet man die Ergebnisse der Speedup- und Effizienzberechnung, so kann man keine großen Diskrepanzen 
diesbezüglich zwischen den Sprachen erkennen. Alle profitieren mehr oder weniger von der Parallelisierung.

Der Speedup ist in diesem Beispiel eher gering, dies liegt jedoch am verwendeten Algorithmus, welcher durch
die naive Partitionierung der zu betrachtenden Zahlen Leistungseinbußen in Kauf nimmt.

\subsection{Allokation auf dem Heap}

X10 verwaltet den Speicher mithilfe eines Garbage Collectors, wobei C und Rust auf einen solchen verzichten.
Während Garbage Collector ein sehr hilfreiches Werkzeug sind, um den Programmieraufwand zu verringern, so kann dies
allerdings auch auf Kosten der Laufzeiteffizienz und Verfügbarkeit durch Garbage Collector Pausen geschehen.

Um zu Überprüfen, ob diese Gegebenheit einen messbaren Effekt auf die Laufzeit eines Programmes haben kann,
wurde ein Programm geschrieben, welches kontinuierlich Objekte auf dem Heap erstellt,
welche anschließend wieder aus dem Geltungsbereich verschwinden.
In C muss der Speicher, in dem diese Objekte gespeichert werden, manuell mit "`free"' befreit werden,
in Rust wird dieser Speicher automatisch wieder befreit sobald sie den Geltungsbereich verlassen und bei
X10 werden diese Objekte vom Garbage Collector verwalten.

Die erstellten Objekte sind in diesem Fall Arrays von Integer-Zahlenwerten.
Das Äquivalent zu Arrays in X10 sind Rails, daher wurden in der X10 Implementierung diese verwendet.

\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{lrrrrr}
			\toprule
			Sprache    & $\bar{x}$ & $\title{x}$ & $s$ & $V$ & $MAD$ \\
			\midrule
			C          & 0.3894   & 0.3800 & 0.0191 & 4.9058\% & 0.0100 \\
			C (opt)    & 0.3876   & 0.3800 & 0.0197 & 5.0953\% & 0.0100 \\
			Rust       & 29.5478  & 29.480 & 0.2671 & 0.9038\% & 0.0400 \\
			Rust (opt) & 5.1024   & 5.1000 & 0.0258 & 0.5048\% & 0.0200 \\
			X10        & 339.345  & 338.19 & 2.3484 & 0.6920\% & 0.3900 \\
			X10 (opt)  & 227.8816 & 226.09 & 2.8234 & 1.2390\% & 1.0300 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		Diese Tabelle stellt die Ergebnisse des garbageonly-Benchmarks dar. Dieser Benchmark erstellt insgesamt 1000000
		int-Arrays (beziehungsweise Rails in X10) mit einer Größe von 5000 Elementen.
	}
	\label{fig:garbageonly_table}
\end{figure}

Wie man an den Ergebnissen der Tabelle \ref{fig:garbageonly_table} erkennen kann,
benötigt X10 im Vergleich zu Rust oder C deutlich länger, um die selbe Anzahl an gleich großen Objekten zu erstellen. 
Dies könnte eine Konsequenz des Garbage Collectors sein, es lässt sich jedoch ohne eine genaue Messung des
Speicherverhaltens keine eindeutige Aussage diesbezüglich treffen.

Bei häufiger Erstellung von neuen Objekten weisen Rust und C allerdings trotzdem durch die gemessene Laufzeit
einen nennenswerten Vorteil gegenüber X10 auf. Im Falle von Rust muss der Programmierer obendrein
den Speicher nicht selbst wieder freigeben, denn dies geschieht implizit sobald eine Variable
den Geltungsbereich verlässt. Somit weist Rust gegenüber C ebenfalls trotzt der schlechteren Laufzeit
einen Vorteil auf.

\section{Aufwand des Programmierens}

Im Folgenden wird der Aufwand des Erstellens eines invasiven Programms in jeder der betrachteten
Programmiersprachen verglichen.

\subsection{Projektstruktur}

Zunächst wird die Struktur eines invasiven Projekts in den unterschiedlichen Programmiersprachen verglichen.

Einzelne C und Rust Programme können jeweils mithilfe von octorust kompiliert werden. Gleiches gilt für X10, für
welches x10firm die Kompilierung durchführt.

Zusätzlich hierzu bietet octorust jedoch auch das Kompilieren von Cargo Projekten. Diese weisen zwar einen
höheren Aufwand zu Beginn des Projekts auf, erlauben aber anschließend nutzerfreundliches Einbinden von
externen Bibliotheken in der Cargo.toml Konfigurationsdatei. Im Falle von X10 und C ist eine ähnliche
Funktionalität nicht vorhanden, externe Bibliotheken müssen beim Kompilieren manuell eingebunden werden.

\subsection{Minimales Invade, Infect, Retreat}

Um den Programmieraufwand eines simplen invasiven Programm zu beurteilen, wurde wurde ein Programm geschrieben, 
welches zuerst eine "`Invade"'-Operation durchführt und anschließend eine simple `"Hello World"'
Funktion auf jedem der reservierten Rechenelemente in der "`Infect"'-Phase ausführt.
Das Programm wartet anschließend bis alle Rechenlemente mit der Ausführung beendet sind und gibt anschließend
alle Ressourcen in der "`Retreat"'-Phase wieder frei.

\subsubsection{Rust}

Um dieses Programm in Rust zu implementieren, muss man zunächst die notwendigen Strukturen importieren.
Benötigt werden die "`Constraints"' und "AgentClaim"' Strukturen. 
Zusätzlich muss der "`libc::c\char`_void"'-Typ importiert werden, um die Funktionssignatur des Ilets zu definieren.
Außerdem wird zum drucken von `"Hello World!"' die "`helper::printer::print"' Funktion benötigt.

Zunächst werden die Constraints mithilfe der "`Constraints"'-Struktur initialisiert. Anschließend können diese
bei der Initialisierung einer Instanz der "`AgentClaim"'-Struktur verwendet werden. Wurde der Konstruktor
der "`AgentClaim"'-Struktur aufgerufen, wurde die "`Invade"'-Operation bereits durchgeführt. Es muss nun nur noch
die "`infect"'-Methode aufgerufen werden. Dieser Methode wird eine Closure als Parameter übergeben, welche den
Text "`Hello World"' auf die Kommandozeile druckt. Sobald die "`infect"'-Methode aufgerufen wurde, wartet der
Hauptfaden des Programms automatisch darauf, dass die einzelnen Rechenelemente ihre Ausführung beendet haben.

Hiernach muss der Programmierer keine zusätzlichen Instruktionen aufrufen. Die "`Retreat"'-Phase wird beim
Verlassen des Geltungsbereichs automatisch durchgeführt.

Eine beispielhafte Implementierung wird in Listing \ref{code:rust_minimal_infect} veranschaulicht.

\begin{lstlisting}[float,caption={Minimales Invade, Infect, Retreat in Rust},label=code:rust_minimal_infect]
#![no_std]

extern crate libc;
extern crate octolib;
use libc::c_void;
use octolib::helper::printer::*;
use octolib::improvements::constraints::Constraints;
use octolib::improvements::claim::AgentClaim;

#[no_mangle]
pub extern "C" fn rust_main_ilet(claim: u8) {

    let mut ilet = |params: *mut c_void| { print("Hello World\n\0"); };
    let mut constr = Constraints::new(4, 4);
    let mut agent = AgentClaim::new(constr);
    agent.infect(ilet, None);

}
\end{lstlisting}

\subsubsection{X10}

Soll das Programm in X10 implementiert werden, so muss man zuerst die benötigten Klassen importieren. Es werden 
mindestens die Klassen "`invasic.constraints.PEQuantity"', "`invasic.IncarnationID"' und "`invasic.Claim"'
benötigt. Zusätzlich muss "`x10.io.Console"' importiert werden um das Drucken auf die Kommandozeile zu
ermöglichen.

Wie bereits bei Rust werden zunächst die Constraints initialisiert. Hierzu
ruft man lediglich den Konstruktor der Klasse "`PEQuantity"' auf. Man kann dies mithilfe
des "`\char`&\char`&"'-Operators mit weiteren Constraints-Attributen verbinden.
Anschließend führt man die "`Invade"'-Phase mithilfe der statischen "`Claim.invade"'-Methode aus und erhält
als Rückgabewert den erstellten Claim.
Um dann die "`Infect"'-Phase zu beginnen, muss auf diesem Claim die "`infect"'-Methode verwendet werden.
Als Parameter erhält diese eine Closure, welche "`Hello World"' auf die Kommandozeile druckt.
Sobald die Methode aufgerufen wurde, wartet der Hauptfaden des Programms auf das Ende der Ausführung der
verwendeten Rechenelemente.

Nach erfolgreicher Ausführung der "`infect"'-Phase, muss dann noch manuell die "`retreat"'-Method des Claims
aufgerufen werden.

\textcolor{red}{impl Retreat manuell Fragezeichen, TileSharing}

Eine beispielhafte Implementierung wird in Listing \ref{code:x10_minimal_infect} veranschaulicht.

\begin{lstlisting}[float,caption={Minimales Invade, Infect, Retreat in X10},label=code:x10_minimal_infect]
import x10.io.Console;

import invasic.constraints.PEQuantity;
import invasic.constraints.TileSharing;
import invasic.IncarnationID;
import invasic.Claim;

class Infect {
	public static def main(Array[String]) {

	    val ilet = (id: IncarnationID) => {
	        Console.OUT.println("Hello World!");
	    };

	    val constraints = new PEQuantity(4, 4) && TileSharing.WITH_OTHER_APPLICATIONS;
        val claim = Claim.invade(constraints);
        claim.infect(ilet);
	}
};
\end{lstlisting}

\subsubsection{C}

Im Gegensatz zu Rust und X10 müssen die verwendeten Strukturen nicht explizit importiert werden. Es muss lediglich
"`octopos.h"' mit der Präprozessor-Anweisung "`include"' verwendet werden.
Um auf die Kommandozeile drucken zu können, muss zusätzlich "`stdio.h"' importiert werden.

Die Implementierung des eigentlichen Programms erweist sich in C jedoch als deutlich komplexer als es bei
Rust oder X10 der Fall war.

Die Constraints werden mithilfe der "`agent\char`_constr\char`_create"'-Funktion initialisiert
und müssen anschließend mit diversen "`agent\char`_constr\char`_set\char`_..."'-Funktionen konfiguriert werden.
Mit dieser konfigurierten "`constraints\char`_t"'-Struktur kann nun eine "`agentclaim\char`_t"'-Struktur mithilfe
der "`agent\char`_claim\char`_invade"'-Funktion initialisiert werden.

Nach dieser "`Invade"'-Operation muss man in C manuell über alle Rechenelemente iterieren, dabei
"`simple\char`_ilet"'-Strukturen für diese erstellen und anschließend mit der "`proxy\char`_infect"'-Funktion
die Ausführung beginnen. Als Ilet-Funktion muss eine volle C Funktion verwendet werden,
da die Sprache keine Closures oder ähnliche Konstrukte bietet.
Damit der Hauptfaden auf das Ausführungsende der einzelnen Rechenelemente wartet, muss
man manuell Signalstrukturen verwenden.

Nachdem die Recheneinheiten signalisiert haben, dass sie ihre Ausführung beendet haben, muss man noch manuell
die "`Retreat"'-Phase beginnen und anschließend mit der "`shutdown"'-Funktion die Ausführung des Programms beenden.

\textcolor{red}{impl Retreat}

Eine beispielhafte Implementierung wird in Listing \ref{code:c_minimal_infect} veranschaulicht.

\begin{lstlisting}[float,caption={Minimales Invade, Infect, Retreat in C},label=code:c_minimal_infect]
#include <octopos.h>
#include <stdio.h>

void signaler(void* sig) {
    simple_signal* s = (simple_signal*)(sig);
    simple_signal_signal_and_exit(s);
}

void ILetFunc(void *signal) {
    printf("Hello World!\n");
    simple_ilet answer;
    simple_ilet_init(&answer, signaler, signal);
    dispatch_claim_send_reply(&answer);
}

void main_ilet(claim_t claim) {

    constraints_t myConstr = agent_constr_create();
    agent_constr_set_quantity(myConstr, 4, 4, 0);
    agent_constr_set_tile_shareable(myConstr, 1);
    agentclaim_t myClaim = agent_claim_invade(0, myConstr);

    simple_signal sync;
    simple_signal_init(&sync, agent_claim_get_pecount(myClaim));

    for (int tile=0; tile < get_tile_count(); tile++) {
        int pes=agent_claim_get_pecount_tile_type(myClaim,  tile, 0);
        if (pes) {
            proxy_claim_t pClaim = agent_claim_get_proxyclaim_tile_type(myClaim, tile, 0);

            simple_ilet ILet[pes];
            for (int i = 0; i < pes; ++i) {
                simple_ilet_init(&ILet[i], ILetFunc, &sync);
            }

            proxy_infect(pClaim, &ILet[0], pes);
        }
    }

    simple_signal_wait(&sync);
    shutdown(0);
}
\end{lstlisting}

\subsubsection{Vergleich}

Die Vorgehensweisen bei Rust und X10 sind nahezu identisch. Der einzige nennenswerte Unterschied hierbei ist es, dass
man in Rust keine explizite "'Retreat"'-Operation initialisieren muss.
Das C Programm ist im Vergleich zu den beiden anderen Programmiersprachen hingegen komplexer und somit auch
fehleranfälliger. Zudem benötigt ein solches C Programm ungefähr doppelt so viele 
Codezeilen wie die äquivalenten Rust oder X10 Programme. Obendrein ist es in C nicht möglich, Closures oder
ähnliche Konstrukte zu verwenden, Rust und X10 unterstützen dies jedoch.

\textcolor{blue}{Code rauslassen}

