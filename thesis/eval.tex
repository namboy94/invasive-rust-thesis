\chapter{Evaluation}\label{sec:eval}

%TODO Speedup Berechnung, Tabellen statt grafiken

Im folgenden wird der Gebrauch von Rust im Zusammenhang mit dem invasiven Computing evaluiert. Hierbei
wird vor allem mit den bereits unterstützten Sprachen C und X10 verglichen.

\section{Laufzeitverhalten, Kompilierungsdauer und Dateigröße}

Zu Beginn werden das Laufzeitverhalten, die Kompilierungsdauer und die Dateigröße kompilierter Programme zwischen
den drei Programmiersprachen verglichen.

Es wurde ein Python-Script geschrieben, welches es ermöglicht, die unterschiedlichen Benchmark-Programme nacheinander
abzuarbeiten und währenddessen die Compilezeit, Dateigröße und Laufzeitdauer jedes Programms zu messen.

Alle Programme wurden auf der folgenden Hardware/Software Konfiguration ausgeführt:

\begin{itemize}
	\item{CPU: Intel Core i5-5200U @ 2.2GHZ x 2}
	\item{RAM: 8GB}
	\item{OS: Antergos Linux, Kernel 4.12.13-1-ARCH}
	\item{gcc: 6.3.0}
	\item{IRTSS: 2017-06-07-nightly}
	\item{rustc: 1.19.0-nightly}
	\item{jdk: openjdk 1.8.0\char`_131}
	\item{octorust: Version 1.0.0}
	\item{x10i: Commit}
\end{itemize}

Im Falle der Programmiersprache Rust wurden immer zwei Szenarien betrachtet: Einmal wenn mit Compiler-Optimierungen
kompiliert wurde und einmal ohne. Die Variante ohne Optimierungen wird als ``Rust (Debug)'' kenntlich gemacht,
wohingegen die Variante mit Optimierungen als ``Rust (Release)'' bezeichnet wird.

\subsection{Vergleich der Anlaufzeit}

Es wird überprüft, wie lange ein Programm, welches in einer der respektiven Programmiersprachen geschrieben wurde,
benötigt, um die Ausführung zu starten und anschließend wieder aufzuhören.

\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{lrrr}
			\toprule
			Sprache & Laufzeit & Compilezeit & Dateigröße \\
			\midrule
			C & 0 & 0 & 0 \\
			Rust (Debug) & 0 & 0 & 0 \\
			Rust (Release) & 0 & 0 & 0 \\
			X10 & 0 & 0 & 0 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		Diese Tabelle stellt die Messergebnisse des startup-Benchmarks dar. Dieser Benchmark simuliert das Starten und sofortige
		Schließen eines Programms.
	}
	\label{fig:startup_table}
\end{figure}

Anhand dieser Werte kann man prinzipiell erkennen, dass die Anlaufzeiten von C und Rust sich sehr nahe sind, während X10
hierfür ca. 2 Sekunden länger benötigt.
Außerdem benötigt das X10 Programm weitaus länger um die Kompilierung auszuführen, in diesem Fall dauert die Kompilierung eines
X10 Programms X-mal so lange wie die eines Rust-Programms.
Zudem sind die Dateigrößen der kompilierten X10-Programme in diesem Beispiel x-mal größer als im Falle eines Rust-Programms.
C-Programme weisen hierbei die insgesamt kürzesten Kompilierungszeiten und Dateigrößen auf.

\subsection{Berechnen von Primzahlen}

Um die Rechenleistung der verschiedenen Programmiersprachen bei einem intensiveren Problem zu vergleichen, wurden
Programme geschrieben, welche Primzahlen berechnen. Hierbei wurden zwei unterschiedliche Ansätze verwendet: Zum einen
eine naive Berechnung, welche jede Zahl individuell auf Teilbarkeit mit kleineren Zahlen prüft und andererseits
das Sieb von Eratosthenes, eine effiziente Methode zum Berechnen von Primzahlen.

Im Falle des Siebs von Eratosthenes kann Rust keine Quadratwurzeloperation durchführen, da diese die Standardbibliothek
benötigen. Daher wurden in allen Sprachen anstelle eine Quadratwurzelfunktion feste Zahlen verwendet, um den Vergleich
zwischen den Sprachen gerecht zu gestalten. Da jedoch nur eine Quadratwurzeloperation für das Sieb des Eratosthenes
benötigt wird, wäre dies ohnehin aller Wahrscheinlichkeit nach kein entscheidender Faktor bei der Laufzeit.

\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{lrrr}
			\toprule
			Sprache & Laufzeit & Compilezeit & Dateigröße \\
			\midrule
			C & 0 & 0 & 0 \\
			Rust (Debug) & 0 & 0 & 0 \\
			Rust (Release) & 0 & 0 & 0 \\
			X10 & 0 & 0 & 0 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		Diese Tabelle stellt die Ergebnisse des naive-primes-Benchmarks dar. Dieser Benchmark berechnet die ersten 50000 Primzahlen
		indem er für jede Zahl individuell alle kleinere Zahlen auf Teilbarkeit prüft.
	}
	\label{fig:primes_naive_table}
\end{figure}

\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{lrrr}
			\toprule
			Sprache & Laufzeit & Compilezeit & Dateigröße \\
			\midrule
			C & 0 & 0 & 0 \\
			Rust (Debug) & 0 & 0 & 0 \\
			Rust (Release) & 0 & 0 & 0 \\
			X10 & 0 & 0 & 0 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		Diese Tabelle stellt die Ergebnisse des eratosthenes-primes-Benchmarks dar. Dieser Benchmark berechnet die ersten 1690000
		Primzahlen mithilfe des Siebs von Eratosthenes.
	}
	\label{fig:primes_eratosthenes_table}
\end{figure}


Hier erkennt man bereits einige Leistungsunterschiede zwischen den Programmiersprachen. Während C eindeutig das
beste Laufzeitverhalten aufweist, hinkt Rust nicht signifikant hinterher, während das Laufzeitverhalten des X10-Programms auch
nach Abzug der größeren Anlaufzeit schlechter als die der beiden Systemsprachen abschneidet.


\subsection{Müll-Ersteller}

X10 verwaltet den Speicher mithilfe eines Garbage Collectors, wobei C und Rust ohne einen solchen auskommen.
Während Garbage Collector ein sehr hilfreiches Werkzeug sind, um den Programmieraufwand zu verringern, so kommt dies
allerdings auch auf Kosten der Laufzeiteffizienz. Vor allem die Garbage-Collector-Pausen sind hierbei ein nicht zu unterschätzender
Faktor.

Um diese Leistungsdifferenz zu veranschaulichen, wurde ein Benchmark-Programm geschrieben, welche kontinuierlich
Objekte auf dem Heap erstellt, welche anschließend wieder aus dem gültigen Anwendungsbereich verschwindet. In C muss der
Speicher, in dem diese Objekte gespeichert werden, manuell befreit werden, in Rust werden diese automatisch ungültig
sobald sie den gültigen Anwendugsbereich verlassen und bei X10 kümmert sich der Garbage Collector darum.

Die erstellten Objekte sind in diesem Fall Arrays von Integer-Zahlenwerten. In Rust sind das Äquivalent
zu Arrays Slices und in X10 heißen diese Rails.

\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{lrrr}
			\toprule
			Sprache & Laufzeit & Compilezeit & Dateigröße \\
			\midrule
			C & 0 & 0 & 0 \\
			Rust (Debug) & 0 & 0 & 0 \\
			Rust (Release) & 0 & 0 & 0 \\
			X10 & 0 & 0 & 0 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		Diese Tabelle stellt die Ergebnisse des garbageonly-Benchmarks dar. Dieser Benchmark erstellt insgesamt 1000000
		Arrays mit einer Größe von 5000.
	}
	\label{fig:garbageonly_table}
\end{figure}

Wie man an den Ergebnissen des Benchmarks erkennen kann, benötigt X10 deutlich länger um die selbe Anzahl an gleich großen
Objekten zu erstellen als C oder Rust es tun. Dies weist darauf hin, dass der Garbage Collector unter Umständen einen signifikanten
Einfluss auf das Laufzeitverhalten haben kann. C und Rust haben hier also einen Vorteil, vor allem Rust, denn
bei dieser Sprache muss der Speicher nicht manuell wieder freigegeben werden, wie es in C der Fall ist.


\section{Sicherheit}

Im folgenden wird die Sicherheit bezüglich undefiniertem Verhalten als Folge von fehlerhaften Speicherzugriffen analysiert.
Hierbei ist vor allem der Vergleich zwischen Rust und C interessant, da einige von Rusts primären Eigenschaften die
Risiken der C-Programmierung beseitigen sollen.

\subsection{Division durch 0}

Dividiert man in C einen Wert durch die Zahl 0, kann es zu undefiniertem Verhalten führen, welches generell
unerwünschtes Verhalten darstellt. Versucht man dies in Rust, so stürzt das Programm sofort ab, es kann nicht zu undefiniertem
Verhalten kommen.

\subsection{Pufferüberlauf}

Ein weiterer Fall, der in C zu undefiniertem Verhalten führt, sind Pufferüberläufe. Diese geschehen, wenn man beispielsweise
in einem Array der Größe n versucht, auf das n+1te Element zuzugreifen. Wie bereits im letzten Vergleich kann dies in 
Rust nicht geschehen, da das Programm abstürzt.

\subsection{Nicht Initialisierte Variablen}

In C ist es möglich, uninitialiserte Variablen zu verwenden, dies führt allerdings zu undefiniertem Verhalten. In Rust hingegen
wird dies bereits vom Compiler verhindert, da er den Gebrauch von uninitialisierten Variablen verbietet. Ein Rust-Programm
welches also uninitialisierte Variablen verwendet kompiliert also gar nicht und kann so natürlich auch nicht
zu undefiniertem Verhalten führen.


\section{Abstraktionen}

Es werden nun die implementierten Abstraktionen der octolib Bibliothek mit den Implementierungen in C und X10 verglichen.

\subsection{Minimales Infect}

\subsection{Cleanup}

\subsection{Closures}

Closures bieten eine praktische Art und Weise, anonyme Funktionen zu nutzen


