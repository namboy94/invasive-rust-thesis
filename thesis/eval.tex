\chapter{Evaluation}\label{sec:eval}

Im folgenden wird der Gebrauch von Rust im Zusammenhang mit dem invasiven Computing evaluiert. Hierbei
wird vor allem mit den bereits unterstützten Sprachen C und X10 verglichen.

\section{Laufzeitverhalten, Kompilierungsdauer und Dateigröße}

Zu Beginn werden das Laufzeitverhalten, die Kompilierungsdauer und die Dateigröße kompilierter Programme zwischen
den drei Programmiersprachen verglichen.

Es wurde ein Python-Script geschrieben, welches es ermöglicht, die unterschiedlichen Benchmark-Programme nacheinander
abzuarbeiten und währenddessen die Compilezeit, Dateigröße und Laufzeitdauer jedes Programms zu messen.

Alle Programme wurden auf der folgenden Hardware/Software Konfiguration ausgeführt:

\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{lr}
			\midrule
			CPU & Intel Core i5-5200U @ 2.2GHZ x 2 \\
			Hauptspeicher & 8GB \\
			Betriebssystem & Antergos Linux, Kernel 4.12.13-1-ARCH \\
			gcc & 6.3.0 \\
			IRTSS & 2017-06-07-nightly \\
			rustc & 1.19.0-nightly \\
			JDK & openjdk 1.8.0\char`_131 \\
			octorust & Version 1.0.0 \\
			x10i & Commit 31183335a89917f489046da746c5181174a7bdb3 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		Dies ist die Hardware/Software Konfiguration des Rechners, auf der die nachfolgenden Programme ausgeführt wurden.
	}
	\label{fig:specs_table}
\end{figure}

Im Falle der Programmiersprache Rust wurden immer zwei Szenarien betrachtet: Einmal wenn mit Compiler-Optimierungen
kompiliert wurde und einmal ohne. Die Variante ohne Optimierungen wird als ``Rust (Debug)'' kenntlich gemacht,
wohingegen die Variante mit Optimierungen als ``Rust (Release)'' bezeichnet wird.

\subsection{Vergleich der Anlaufzeit}

Es wird überprüft, wie lange ein Programm, welches in einer der respektiven Programmiersprachen geschrieben wurde,
benötigt, um die Ausführung zu starten und anschließend wieder aufzuhören.

\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{lrrr}
			\toprule
			Sprache & Laufzeit & Compilezeit & Dateigröße \\
			\midrule
			C & 0 & 0 & 0 \\
			Rust (Debug) & 0 & 0 & 0 \\
			Rust (Release) & 0 & 0 & 0 \\
			X10 & 0 & 0 & 0 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		Diese Tabelle stellt die Messergebnisse des startup-Benchmarks dar. Dieser Benchmark simuliert das Starten und sofortige
		Schließen eines Programms.
	}
	\label{fig:startup_table}
\end{figure}

Anhand der Werte in Tabelle \ref{fig:startup_table} kann man prinzipiell erkennen, dass die Anlaufzeiten von C und Rust sich sehr nahe
sind, während X10 hierfür merklich länger benötigt.
%TODO insert value
Außerdem benötigt das X10 Programm weitaus länger um die Kompilierung auszuführen, in diesem Fall dauert die Kompilierung eines
X10 Programms X-mal so lange wie die eines Rust-Programms.
%TODO insert value
Zudem sind die Dateigrößen der kompilierten X10-Programme in diesem Beispiel x-mal größer als im Falle eines Rust-Programms.
C-Programme weisen hierbei die insgesamt kürzesten Kompilierungszeiten und Dateigrößen auf.

\subsection{Berechnen von Primzahlen}

Um die Rechenleistung der verschiedenen Programmiersprachen bei einem intensiveren Problem zu vergleichen, wurden
Programme geschrieben, welche Primzahlen berechnen. Hierbei wurden zwei unterschiedliche Ansätze verwendet: Zum einen
eine naive Berechnung, welche jede Zahl individuell auf Teilbarkeit mit kleineren Zahlen prüft und andererseits
das Sieb von Eratosthenes, eine effiziente Methode zum Berechnen von Primzahlen.

Im Falle des Siebs von Eratosthenes kann Rust keine Quadratwurzeloperation durchführen, da diese die Standardbibliothek
benötigen. Daher wurden in allen Sprachen anstelle eine Quadratwurzelfunktion feste Zahlen verwendet, um den Vergleich
zwischen den Sprachen gerecht zu gestalten. Da jedoch nur eine Quadratwurzeloperation für das Sieb des Eratosthenes
benötigt wird, wäre dies ohnehin aller Wahrscheinlichkeit nach kein entscheidender Faktor bei der Laufzeit.

\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{lrrr}
			\toprule
			Sprache & Laufzeit & Compilezeit & Dateigröße \\
			\midrule
			C & 0 & 0 & 0 \\
			Rust (Debug) & 0 & 0 & 0 \\
			Rust (Release) & 0 & 0 & 0 \\
			X10 & 0 & 0 & 0 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		Diese Tabelle stellt die Ergebnisse des naive-primes-Benchmarks dar. Dieser Benchmark berechnet die ersten 50000 Primzahlen
		indem er für jede Zahl individuell alle kleinere Zahlen auf Teilbarkeit prüft.
	}
	\label{fig:primes_naive_table}
\end{figure}

\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{lrrr}
			\toprule
			Sprache & Laufzeit & Compilezeit & Dateigröße \\
			\midrule
			C & 0 & 0 & 0 \\
			Rust (Debug) & 0 & 0 & 0 \\
			Rust (Release) & 0 & 0 & 0 \\
			X10 & 0 & 0 & 0 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		Diese Tabelle stellt die Ergebnisse des eratosthenes-primes-Benchmarks dar. Dieser Benchmark berechnet die ersten 1690000
		Primzahlen mithilfe des Siebs von Eratosthenes.
	}
	\label{fig:primes_eratosthenes_table}
\end{figure}

Hier erkennt man bereits einige Leistungsunterschiede zwischen den Programmiersprachen. Während C eindeutig das
beste Laufzeitverhalten aufweist, sind die Werte bei optimiertem Rust nicht signifikant schlechter,
während das Laufzeitverhalten des X10-Programms auch nach Abzug der größeren Anlaufzeit schlechter
als die der beiden Systemsprachen abschneidet.


\subsection{Müll-Ersteller}

X10 verwaltet den Speicher mithilfe eines Garbage Collectors, wobei C und Rust ohne einen solchen auskommen.
Während Garbage Collector ein sehr hilfreiches Werkzeug sind, um den Programmieraufwand zu verringern, so kann dies
allerdings auch auf Kosten der Laufzeiteffizienz und Verfügbarkeit durch Garbage Collector Pausen geschehen.

Um diese Leistungsdifferenz zu veranschaulichen, wurde ein Benchmark-Programm geschrieben, welche kontinuierlich
Objekte auf dem Heap erstellt, welche anschließend wieder aus dem Geltungsbereich verschwinden. In C muss der
Speicher, in dem diese Objekte gespeichert werden, manuell befreit werden, in Rust wird dieser Speicher automatisch befreit
sobald sie den Geltungsbereich verlassen und bei X10 kümmert sich der Garbage Collector um den Speicher.

Die erstellten Objekte sind in diesem Fall Arrays von Integer-Zahlenwerten. Das Äquivalent zu Arrays in X10 sind Rails,
daher wurden diese in diesem Benchmark verwendet.

\begin{figure}[hb]
	\begin{center}
		\begin{tabular}{lrrr}
			\toprule
			Sprache & Laufzeit & Compilezeit & Dateigröße \\
			\midrule
			C & 0 & 0 & 0 \\
			Rust (Debug) & 0 & 0 & 0 \\
			Rust (Release) & 0 & 0 & 0 \\
			X10 & 0 & 0 & 0 \\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption{
		Diese Tabelle stellt die Ergebnisse des garbageonly-Benchmarks dar. Dieser Benchmark erstellt insgesamt 1000000
		Arrays mit einer Größe von 5000.
	}
	\label{fig:garbageonly_table}
\end{figure}

Wie man an den Ergebnissen des Benchmarks erkennen kann, benötigt X10 deutlich länger um die selbe Anzahl an gleich großen
Objekten zu erstellen als C oder Rust es tun. Dies weist darauf hin, dass der Garbage Collector unter Umständen einen signifikanten
Einfluss auf das Laufzeitverhalten haben kann. C und Rust haben hier also einen Vorteil, vor allem Rust, denn
bei dieser Sprache muss der Speicher nicht manuell wieder freigegeben werden, wie es in C der Fall ist. So kann
es dann nicht aus Versehen zu Speicherlecks kommen.

\section{Sicherheit}

Im folgenden wird die Sicherheit bezüglich undefiniertem Verhalten als Folge von fehlerhaften Speicherzugriffen analysiert.
Hierbei ist vor allem der Vergleich zwischen Rust und C interessant, da einige von Rusts primären Eigenschaften die
Risiken der C-Programmierung beseitigen sollen.

\subsection{Division durch 0}

Dividiert man in C einen Wert durch die Zahl 0, kann es zu undefiniertem Verhalten führen, welches auf jeden Fall unerwünscht
ist. Versucht man dies in Rust, so bricht das Programm sofort ab, indem die "`panic\char`_fmt"'-Funktion aufgerufen wird und es
kann nicht zu undefiniertem Verhalten kommen.

\subsection{Pufferüberlauf}

Ein weiterer Fall, der in C zu undefiniertem Verhalten führt, sind Pufferüberläufe. Diese geschehen, wenn man beispielsweise
in einem Array der Größe n versucht, auf das n+1te Element zuzugreifen. Wie bereits im letzten Vergleich kann dies in 
Rust nicht geschehen, da das Programm mit einem Aufruf der "`panic\char`_fmt"'-Funktion die Ausführung beendet.

\subsection{Nicht Initialisierte Variablen}

In C ist es möglich, uninitialiserte Variablen zu verwenden, dies führt allerdings ebenfalls zu undefiniertem Verhalten.
In Rust hingegen wird dies bereits vom Compiler verhindert, da er den Gebrauch von uninitialisierten Variablen verbietet.
Ein Rust-Programm welches also uninitialisierte Variablen verwendet kompiliert also gar nicht und kann so natürlich auch nicht
zu undefiniertem Verhalten führen.


%\section{Abstraktionen}

%Es werden nun die implementierten Abstraktionen der octolib Bibliothek mit den Implementierungen in C und X10 verglichen.

%\subsection{Minimales Infect}

%\subsection{Cleanup}

%\subsection{Closures}

%Closures bieten eine praktische Art und Weise, anonyme Funktionen zu nutzen


