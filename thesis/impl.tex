\chapter{Entwurf und Implementierung}\label{sec:impl}

Im folgenden werden Programme und Bibliotheken entwickelt, welche es ermöglichen, Rust auf dem IRTSS Betriebssystem
verwenden zu können. Dies ermöglicht es dann, Programme, welche vom invasiven Computing Gebrauch machen, in der
Programmiersprache Rust zu schreiben.

\section{Rust auf der SPARC LEON Architektur}

Rust wird derzeit nicht offiziell auf der SPARC-V8 Architektur unterstützt. Rust verwendet jedoch als Backend LLVM,
welches diese Architektur unterstützt und daher ist es prinzipiell möglich, Rust-Programme für diese Architektur zu kompilieren.
Die Rust-Standardbibliothek ist allerdings nicht trivial auf andere Architekturen zu portieren.
Um diese Hürde zu umgehen bietet Rust die Funktion,
Programme mit einer minimalen, platformunabhängigen Untermenge der Standardbibliothek zu kompilieren. Diese Funktion wird hier
ausgenutzt, um eine minimale Implementierung der Programmiersprache auf die SPARC-V8 Architektur zu portieren.

Um ein Rust Programm für eine nicht offiziell unterstütze Architektur zu kompilieren, muss man zuerst die libcore Bibliothek
für die Zielarchitektur kompilieren. Um dies zu erreichen, benötigt man eine JSON-Datei, welche
dem Compiler die nötigen Informationen zur Ziel-Architektur zur Verfügung stellt. Eine solche JSON Datei für die
SPARC-V8 Architektur sieht beispielsweise wie folgt aus\cite{initialSparcSupportGithub}:
\begin{verbatim}
{
    "arch": "sparc",
    "data-layout": "E-m:e-p:32:32-i64:64-f128:64-n32-S64",
    "executables": true,
    "llvm-target": "sparc",
    "os": "none",
    "panic-strategy": "abort",
    "target-endian": "big",
    "target-pointer-width": "32",
    "linker-flavor": "ld",
    "linker": "path_to_sparc_gcc",
    "link-args": [
        "-nostartfiles"
    ]
}
\end{verbatim}
Außerdem wird ein C-Linker, beispielsweise gcc, für die SPARC-V8 Architektur benötigt. Der Pfad zu diesem Linker
muss in der "`linker"'-Option der JSON-Datei angegeben werden.

Sobald man diese JSON Datei erstellt hat, kann man die libcore Bibliothek mit dem "`cargo build"' Befehl kompilieren.
Um dies für SPARC-V8 zu tun, gibt man als Parameter für die "`-{}-target"'-Option den Pfad zur Spezifikations-JSON-Datei an.
Derzeit ist es nicht möglich, libcore mit dem stabilen Rust-Compiler zu kompilieren, da diese Bibliothek Funktionalitäten
verwendet, welche auf dem stabilen Compiler deaktiviert sind. Daher muss ein Nightly-Compiler installiert werden, welches
dank rustup jedoch relativ nutzerfreundlich gestaltet ist. Außerdem sollte die Version der libcore Bibliothek
mit der Version des nightly-Compilers übereinstimmen um versionsabhängige Konflikte bei der Kompilierung zu vermeiden.

Nachdem die libcore Bibliothek erfolgreich kompiliert wurde kann man, wenn rustup verwendet wurde um rustc und cargo zu installieren, 
die resultierende .rlib Datei anderen Rust-Programmen beim Kompilieren zur Verfügung stellen,
indem man diese in das korrekte "`lib"' Unterverzeichniss im lokalen "`.rustup"' Verzeichniss kopiert.
Alternativ kann man das libcore Projekt direkt durch die Abhängigkeiten in der Cargo.toml Datei
eines Cargo Projekts einbinden.

Damit ein Rust-Programm libcore anstelle der Standardbibliothek verwendet, muss man mit der Anweisung "`\char`#![no\char`_std]"'
am Anfang des Programms kenntlich machen, dass das Programm ohne die Standardbibliothek kompiliert werden soll.
Außerdem müssen die Funktionen "`eh\char`_personality"', "`eh\char`_unwind\char`_resume"' und
"`panic\char`_fmt"' in diesem Programm manuell implementiert werden. Nennenswert ist vor allem letztere, denn diese Funktion
wird aufgerufen, sobald ein Programm nach einer unbehandelten Ausnahme kontrolliert abstürzt.
Der Anfang eines zu kompilierenden Programms muss also beispielsweise wie folgt aussehen:
\begin{verbatim}
#![feature(lang_items, libc)]
#![no_std]
#![no_main]

#[lang = "eh_personality"] extern fn eh_personality() {}
#[lang = "eh_unwind_resume"] extern fn eh_unwind_resume() {}
#[lang = "panic_fmt"] fn panic_fmt() -> ! { loop {} }
\end{verbatim}

Um dann das Programm zu kompilieren, verwendet man entweder den "`rustc"' Befehl bei eigenständigen "`.rs"' Dateien oder den
"`cargo build"' Befehl für Cargo Projekte. Beiden Befehlen muss dann wie auch beim Kompilieren von libcore die 
Spezifikations-JSON-Datei als Argument für die "`-{}-target"'-Option übergeben werden. 

\section{Erstellung des octorust Hilfsprogramms}

Um das relativ komplizierte und fehleranfällige Kompilieren für Rust-Programme auf der SPARC-V8 Architektur zu vereinfachen, als
auch besagte Rust-Programme mit dem IRTSS Betriebssytem zu verwenden, wurde ein Python-Programm geschrieben, welche diese Schritte
vereinfacht. Das Programm wurde in Python geschrieben, da Pythons Standardbibliothek viele nützliche Funktionen zur Manipulation
von Dateien bietet, welches sich für diesen Zweck als hilfreich erwiesen hat. Außerdem bietet Python mit "`argparse"' ein
praktisches Modul zum Verarbeiten von Kommandozeilen-Argumenten.

Das Programm verwendet "`python-setuptools"' und eine dafür konfigurierte "`setup.py"' Datei, um das Programm lokal zu installieren.
Während dem Installationsprozesses wird zum Einen das octorust-Programm selbst lokal als Python Modul installiert und das
"`octorust"' Skript als ausführbare Datei dem Nutzer zur Verfügung gestellt.
Gleichzeitig wird ein Verzeichnis namens .octorust
im Heimverzeichnis des derzeitigen Nutzers erstellt, in dem IRTSS-builds, die octolib Rust-Bibliothek, welche später 
genauer erläutert wird, als auch ein SPARC-V8 gcc, insofern dass ein
solcher nicht bereits installiert ist und im Pfad gefunden werden kann.
Zudem werden für alle unterstützten Architekturen die libcore, libc und liballoc Bibliotheken kompiliert und in den
Installationspfad des derzeit verwendeten Rustup-Toolchains kopiert.

Octorust bietet die folgenden Optionen:
\begin{description}

	\item[-h, -{}-help]
	Diese Option druckt einen Nutzungshinweis inklusive aller möglichen Kommandozeilenoptionen.
	
	\item[-a. -{}-architecture]
	Diese Option ermöglicht es, eine IRTSS Zielarchitektur zu wählen. Zur Wahl stehen "`x86guest"', "`x64native"' als auch "`leon"'.
	Sollte diese Option nicht angegeben werden, wird standardmäßig für die "`x86guest"' Architektur kompiliert.
	
	\item[-v, -{}-variant]
	Diese Option ermöglicht es, eine IRTSS-Variante zu wählen, beispielsweise "`generic"' oder 	"`4t5c-nores-chipit-w-iotile"'.
	Sollte diese Option nicht angegeben werden, wird je nach gewählter Architektur eine passende Standardvariante verwendet.
	Im Falle von "`x86guest"' und "`x64native"' wird die Variante "`generic"' gewählt und für "`leon"' die Variante
	"`4t5c-nores-chipit-w-iotile"'.
	
	\item[-o, -{}-output]
	Mit dieser Option kann der Pfad zur resultierenden Ausgabedatei explizit angegeben	werden. Ansonsten ermittelt octorust
	automatisch einen sinnvollen Ausgabenamen, beispielsweise "`foo.out"' für ein Cargo-Project mit dem Namen "`foo"'.
	
	\item[-k, -{}-keep]
	Wird diese Option verwendet, werden jegliche temporäre Dateien, die während dem Kompilieren und dem Linken erstellt werden im
	Anschluss nicht gelöscht. Dies beinhaltet unter anderem erstellte statische Bibliotheken oder Objekt-Dateien.
	
	\item[-r, -{}-run]
	Wird diese Option verwendet, wird das Programm nach dem Kompilieren sofort ausgeführt. Für andere Architekturen als
	"`x86guest"' wird dabei vorausgesetzt dass das Virtualisierungsprogramm "`qemu"' installiert ist.
	
	\item[-i, -{}-irtss-build-version]
	Mithilfe dieser Option kann man eine spezifische IRTSS Version verwenden.
	
	\item[-{}-release]
	Wird diese Option verwendet, werden Compiler-Optimierungen für Rust-Programme aktiviert.
	
	\item[-{}-fetch-irtss]
	Mithilfe dieser Option können IRTSS-builds von \\
	https://www4.cs.fau.de/invasic/octopos/ heruntergeladen werden. Hierfür ist jedoch
	eine gültige Nutzername/Passwort-Kombination in einer .netrc Datei im folgenden Format vonnöten:
	\begin{verbatim}
	machine www4.cs.fau.de
	login NUTZERNAME
	password PASSWORT
	\end{verbatim}
\end{description}

Unterstützt wird das Kompilieren von eigenständigen C-Quelldateien und Rust-Quelldateien, als auch das Kompilieren von
Cargo-Projekten. Cargo-Projekte bieten durch das Abhängigkeitsmanagement zusätzlich den Gebrauch von Rust-Bibliotheken, vor
allem der octolib-Bibliothek, welche eigens für die Interaktion zwischen Rust und IRTSS entwickelt wurde. Daher werden sich die
folgenden Prozesse primär mit dem Kompilierungsvorgang der Cargo-Projekte beschäftigen.

\subsection{Struktur eines invasiven Cargo-Projekts}

Wie normale Cargo-Projekte besteht ein invasives Cargo-Projekt aus mindestens einem "`src"' Verzeichnis, einer Haupt-Bibliotheksdatei
und einer "`Cargo.toml"' Datei. Bei invasiven Cargo-Projekten muss das "`crate-type"' Attribut immer als
"`staticlib"' angegeben werden,
damit das Projekt als statische Bibliothek kompiliert wird, welche dann mit dem IRTSS Betriebssystem verlinkt werden kann.

Zusätzlich muss die Haupt-Quelldatei des Projekts mit "`\char`#![no\char`_std]"' beginnen und anstelle der main()
Funktion muss eine "`pub extern \char`"C\char`""' Funktion namens "`rust\char`_main\char`_ilet"' als Startpunkt des Programms
verwendet werden.
Diese Funktion nimmt genau einen Parameter entgegen, welcher vom Typ u8 ist.
Über dieser  Funktion muss außerdem "`\char`#[no\char`_mangle]"' stehen, damit die Funktion aus einem C Kontext heraus
aufrufbar ist.
Außerdem sollte die octolib Bibliothek mit einem "`extern crate octolib;"' eingebunden werden.

Die Haupt-Quelldatei eines invasiven Cargo-Projekts sähe demnach minimal wie folgt aus:
\begin{verbatim}
#![no_std]

extern crate octolib;

#[no_mangle]
pub extern "C" fn rust_main_ilet(claim: u8) {

}
\end{verbatim}

\subsection{Kompilieren}

Vor der Kompilierung wird im Falle, dass "`leon' als Zielarchitektur ausgewählt wurde, zuerst eine wie in Kapitel 3.1 erläuterte
JSON-Spezifikationsdatei generiert, in der der Pfad zum SPARc-V8 gcc Compiler automatisch eingetragen wird. Für die anderen beiden
Zielarchitekturen ist ein solcher Schritt nicht nötig, da diese offiziell unterstützt werden. 
Nachdem diese Spezifikationsdatei generiert wurde, wird das Projekt mithilfe des "`cargo"'-Befehls als statische Bibliothek 
kompiliert. Wurde das Projekt erfolgreich kompiliert, wird anschließend eine minimale C Datei generiert,
welche die vom IRTSS benötigte main\char`_ilet Funktion implementiert und innerhalb
dieser die rust\char`_main\char`_ilet Funktion aufruft. Im Anschluss daran wird dann noch die "`shutdown"' Funktion aufgerufen um die 
Ausführung des Programms zu beenden. Diese generierte C Datei wird mithilfe eines passenden gcc Compilers als Objekt-Datei kompiliert
und anschließend mit dem IRTSS Betriebssystem und der zuvor kompilierten statischen Rust-Bibliothek verlinkt.
Nun sollte eine ausführbare Datei
existieren, welche auf einem x86 Rechner im Falle der "`x86guest"' Architektur nativ ausführbar ist oder im Falle von
"`x64native"' und "`leon"' mithilfe eines Emulators wie "`qemu"'.

Im Anschluss an die Kompilierung werden, vorausgesetzt die "`-{}-keep"'-Option wurde nicht verwendet, jegliche temporäre Dateien
gelöscht, beispielsweise die statische Rust-Bibliothek, die minimale C Datei oder auch die C
Objektdatei.

\section{octolib}

Zusätzlich zum octorust Programm wurde ebenfalls eine Rust-Bibliothek names octolib geschrieben. Diese Bibliothek soll
die Interaktion zwischen Rust und dem IRTSS Betriebssystem ermöglichen und and die neue Programmiersprache anpassen. IRTSS
bietet eine C-Schnittstelle an, welche man mithilfe der Foreign Function Interface und der libc Bibliothek aus Rust heraus ansprechen
kann. Die libc Bibliothek bietet die Möglichkeit, Komponenten, welche die Standardbibliothek benötigen, auszulassen, daher ist sie
auch auf der SPARC-V8 Architektur benutzbar.

Die octolib Bibliothek wird vor dem Kompilieren als Abhängigkeit in die Cargo.toml Datei eingefügt und so dem Projekt hinzugefügt.
Hierfür wird mithilfe des "`toml"' Python Moduls der derzeitige Inhalt der Cargo.toml Datei eingelesen, der
Pfad zur octolib Bibliothek in diese Daten injiziert und anschließend wird die Datei mit den neuen Daten überschrieben.
Eine Kopie der ursprünglichen Daten werden vorerst noch im Hauptspeicher behalten und nachdem die Kompilierung beendet wurde,
wobei hier egal ist ob diese erfolgreich war oder nicht, werden die alten Daten wieder in die Cargo.toml Datei
geschrieben, um zu vermeiden dass die Cargo.toml Datei eine Konfiguration enthält, die auf lokale Gegebenheiten basieren.
Damit die Bibliothek für jedes zu kompilierende Programm auffindbar ist, wird eine lokale Kopie während der Installation des
"`octorust"'-Programms im "`~/.octorust"' Verzeichnis erstellt.

\subsection{Struktur}

Octolib besteht aus einer Hauptbibliotheksdatei namens "`lib.rs"', welche alle anderen Module innerhalb des Projekts einbindet. Diese
Datei implementiert außerdem die in Kapitel 3.1 erwähnten Funktionen "`eh\char`_personality"', "`eh\char`_unwind\char`_resume"' und
"`panic\char`_fmt"', so dass nicht jedes einzelne Projekt diese aufs Neue implementieren muss. Sobald die octolib Bibliothek
mit der Anweisung "`extern crate octolib;"' ins Projekt eingebunden wurde, sind diese Funktionen ebenfalls vorhanden.

Die Bibliothek bietet die folgenden Module:

\begin{description}

	\item[bindings] 
	Dieses Modul enthält die direkten C-Rust Bindings zur C-Schnittstelle des IRTSS.
	
	\item[helper]
	Dieses Modul enthält eine Sammlung an Hilfsfunktionen, die nicht direkt mit dem IRTSS in Verbindung stehen,
	aber trotzdem bei der Pogrammierung nützlich sein können
	
	\item[improvements]
	Rust-spezifische Abstraktionen, die es dem Programmierer erleichtern, Programme mit Rust für das IRTSS zu schreiben.
	
	\item[octo\char`_structs]
	Rust-äquivalente Structs zu denen, die in der C-Schnittstelle verwendet werden.
	
	\item[octo\char`_types]
	Rust-äquivalente Typen zu denen, die in der C-Schnittstelle verwendet werden.

\end{description}

\subsection{Direkte C-Rust Bindings}

Im ersten Schritt wurden die Funktionen der C Schnittstelle direkt Eins-zu-Eins als Rust-Funktionen eingebunden. Dank der
Foreign Function Interface ist dies ein relativ simples Unterfangen, es müssen lediglich die Parameter- und Rückgabetypen
an die neue Programmiersprache angepasst werden. Für die meisten Typen gibt es direkte Äquivalente in Rust, jegliche anderen Typen
stellt die libc Bibliothek zur Verfügung. Ein nennenswertes Beispiel eines Typs der nicht in Rust enthalten ist, ist der
"`void"' Typ. Dieser Typ kann beispielsweise durch den c\char`_void Typen aus der libc Bibliothek emuliert werden.
Void-Pointer (void*), welche an einigen Stellen der C-Schnittstelle verwendet werden, können so als "`*mut c\char`_void"'
dargestellt werden.

Um die Funktionen erfolgreich in die Rust-Bibliothek einbinden zu können, muss man einen "`extern"'-Block erstellen und dort
die Funktionsdefinitionen vornehmen. Damit diese auch von anderen Modulen oder Projekten aufgerufen werden können, müssen diese
als "`pub fn"` deklariert werden. Da diese Funktionen lediglich importierte C-Funktionen ohne jegliche Sicherheitsgarantien
sind, muss man bei jedem Gebrauch dieser Funktionen einen "`unsafe"'-Block verwenden.

\subsubsection{Structs und Typen}

Zusätzlich zu den Funktionsdefinitionen mussten die in IRTSS definierten structs und Typen ebenfalls portiert werden.
Dank der \char`#[repr(C)] Anweisung kann man in Rust Structs erstellen, welche kompatibel mit den C-Äquivalenten sind.
Diese Structs sind teils von Platform-spezifischen Konstanten abhängig, welche man in Rust mit der
\char`#[cfg(target\char`_arch = "arch")] Anweisung für unterschiedliche Architekturen definieren kann.
benutzerdefinierte Typen lassen sich in Rust durch Schlüsselwort "`type"' erstellen.

\subsubsection{Das Helper-Modul}

Das helper-Modul enthält Adapter für C-Funktionen, für die es in Rust ohne Zugriff zur Standardbibliothek keine Alternative existiert.
So werden beispielsweise mehrere Adapter um die "`printf"'-Funktion geboten, welche je eine andere Anzahl an
zusätzlichen Parametern angeben, um diese Variablen ausdrucken zu können.

Beachtet werden muss bei diesen print-Funktionen, dass die überreichten Strings manuell Null-terminiert werden müssen. Um
"`Hello World"' zu drucken, muss man also wie folgt vorgehen:

\begin{verbatim}
print("Hello World\n\0");
\end{verbatim}

\subsection{Rust-spezifische Verbesserungen}

%TODO Bei den Basics: Constraints, Claim, ilet, Tile

Im folgenden werden verschiedene Abstraktionen über die direkten C-Rust Bindings erstellt, welche das Programmieren
vereinfachen und die Stärken von Rust ausnutzen sollen.

\subsubsection{Constraints}

Die "`Constraints"' Struktur ist eine leichte, objektorientierte Abstraktion für die Constraints, mit denen die Anzahl Ressourcen, die
einem Claim zur Verfügung stehen, spezifiziert werden.
Es bietet einen Konstruktor, welcher eine neue "`constraints\char`_t"' Struktur mithile der "`agent\char`_constr\char`_create"'
Funktion aus der C-Schnittstelle erstellt und anschließend einige Standardwerte setzt. Dem Konstruktor werden
zudem 2 Parameter übergeben, welche die minimale und maximale Anzahl an Prozessorelementen spezifizieren.

Alle Parameter der Constraints lassen sich nachträglich durch Methoden der Struktur ändern. Hierbei profitieren vor allem die Methoden,
welche boolesche Werte als Parametertypen besitzen, denn diese werden in den direkten C-Rust Bindings statt mit "`bool"'-Werten mit
u8-Werten aufgerufen. Dies liegt daran, dass es in C keinen "`bool"' oder ähnlichen Typen gibt, dort werden Zahlenwerte auf den
Wert 0 geprüft. Dies wird in den Methoden dieser Struktur jedoch abstrahiert, so dass man in Rust den "`bool"'-Typ verwenden kann.

Außerdem unterstützt die Methode "`merge\char`_constraints"' anstelle einer "`constraints\char`_t"' Struktur aus der
C-Schnittstelle eine in Rust definierte "`Constraints"' Struktur. Möchte man hierbei trotzdem lieber eine
"`constraints\char`_t"'-Struktur verwenden, so kann stattdessen die "`merge\char`_constraints\char`_t"' Methode verwendet werden.

Um Zugriff auf die interne "`constraints\char`_t"' Struktur zu erhalten, kann die
"`to\char`_constraints\char`_t"' Methode aufgerufen werden. Hiernach ist die Constraints-Struktur selbst nicht mehr verwendbar,
da die interne "`constraints\char`_t"'-Variable nicht mehr im Besitz des zugehörigen Speichers ist.

\subsubsection{Closures}

Rust Closures können nicht ohne Weiteres einer C-Schnittstelle als Parameter übergeben werden. Somit ist es mit den direkten
C-Rust Bindings nicht möglich, Closures zu verwenden, um Code auf den Rechenelementen auszuführen. Dies wäre jedoch eine
wünschenswerte Funktionalität. Da Closures aus der Funktion selbst als auch ihrem Erstellungskontext\cite{closureWikiDe}
bestehen, ist es nicht möglich die Closure direkt zu einer normalen Rust Funktion zu konvertieren. Stattdessen erstellt
man einen Zeiger auf die Datenregion, welche die Closure repräsentiert und übergibt diesen dann einer
"`extern \char`"C\char`""' Funktion, welche aus diesem Zeiger die Closure zurückgewinnt.
Diese "`extern \char`"C\char`""'-Funktion kann dann der C-Schnittstelle zusammen mit dem Zeiger
auf die Closure-Daten übergeben werden.

Die Erstellung des Closure-Zeigers wird direkt in der später genauer erläuterten "`infect"'-Methode der "`AgentClaim"'-Struktur
erledigt, während zur Rückkonvertierung eine "`extern \char`"C\char`""'-Funktion namens "`execute\char`_closure"' erstellt wurde.

\subsubsection{AgentClaim}

Die größte Abstraktion in der octolib Bibliothek ist die "`AgentClaim"' Struktur. Diese bietet zunächst einmal eine Abstraktionsschicht
über die `agentclaim\char`_t` Struktur aus der C-Schnittstelle und verschiedene Methoden um diese zu verwenden.

Der Konstruktor nimmt als einzigen Parameter eine "`Constraints"'-Struktur entgegen, welche verwendet wird um die
Ressourcen des Claims zu definieren. Mit diesen Constraints wird dann eine interne "`agentclaim\char`_t"'-Struktur initialisiert,
welche für alle folgenden Methodenaufrufe verwendet wird. Es wird also bereits im Konstruktor implizit die
"`Invade"'-Phase des invasiven Computing ausgeführt.
%TODO Evtl noch new_from_constraints_t

Eine praktische Methode fürs Debugging ist "`set\char`_verbose"'. Diese Methode erlaubt es, die Ausführlichkeit der auf
die Kommandozeile gedruckten Informationen der "`AgentClaim"'-Struktur zu beeinflussen.

Die "`reinvade"'-Methode elaubt es, eine "`Reinvade"'-Operation auf dem Claim auszuführen. Diese erlaubt es,
die von der internen "`agentclaim\char`_t"'-Struktur verwendeten Constraints zu aktualisieren.  Diese Methode nimmt einen
optionalen Parameter an, mit dem man komplett neue Constraints setzen kann.
Werden neue Constraints gesetzt, werden die alten Constraints mit der "`agent\char`_constr\char`_delete"'-Funktion aus dem Speicher
gelöscht. 

Die wohl wichtigste Methode der "`AgentClaim"'-Struktur ist die "`infect"'-Methode. Mit dieser kann eine invasive "`Infect"'-Operation
auf dem Claim ausgeführt werden. Dieser Methode wird eine Funktion oder eine Closure als Parameter übergeben, welche dann auf den
Rechenelementen des Claims ausgeführt werden. Zusätzlich können ebenfalls Parameterdaten für die einzelnen Recheneinheiten
übergeben werden. Diese Parameterdaten werden als ein Array von Void-Zeiger Daten übergeben. Die Anzahl der Elemente des Arrays
müssen mit den vom Claim reservierten Rechenelementen übereinstimmen, ansonsten kann es zu Fehlern oder sogar zum Absturz
des Programms kommen.

In der "`infect"'-Methode werden Signal-Strukturen aus der C-Schnittstelle verwendet, um die Kommunikation zwischen verschiedenen 
Rechenelementen zu verwalten.
Um dies zu vereinfachen, wird die übergebene Funktion oder Closure nochmals von einer Closure umgeben, welche eine Referenz auf 
eine in der "`infect"'-Methode erstellten Signal-Struktur besitzt und über dieses Signal signalisiert, wann diese Closure
die Ausführung ihrer Aufgabe beendet hat. Hierdurch ist es möglich, nach der Initialisierung der Ilets auf die
vollständige Abarbeitung dieser zu warten oder alternativ das Signal, mit dem die einzelnen Ilets kommunizieren, als
Rückgabeparameter zu verwenden. Um beide dieser Varianten zu bieten, gibt es zusätzlich zur "`infect"'-Methode, welche
auf die vollständige Ausführung der Ilets wartet, die "`infect\char`_async"'-Methode, welche die "`simple\char`_signal"'-Struktur,
mit der die Ilets das Ende ihrer Ausführung signalisieren, als Rückgabewert verwendet. Anschließend kann der Nutzer mit der 
"`simple\char`_signal\char`_wait"'-Funktion aus der C-Schnittstelle auf die vollständige Ausführung aller Ilets warten.
Die interne Closure, welche die Kommunikation über Signale implementiert, wird anschließend zu einem Void-Zeiger konvertiert,
welche den Ilets dann als Datenparameter übergeben wird.

Für jedes %Tile und
Rechenelement wird iteriert und ein Ilet initialisiert. Diese Ilets erhalten die "`execute\char`_closure"'-Funktion als ihren
Funktionsparameter und den Closure-Zeiger als ihren ersten Datenparameter. Wurden der "`infect"'-Methode zusätzliche Datenparameter
übergeben, so werden diese als zweite Datenparameter den Ilets übergeben. Nachdem ein Ilet initialisiert wurde, wird
die eigentliche "`Infect"'-Operation durchgeführt.

Das bereits in Kapitel 2.1.2 erwähnte Drop-Trait für Rust-Strukturen wird für die "`AgentClaim"'-Struktur implementiert.
Verlässt eine Instanz der "`AgentClaim"'-Struktur den Geltungsbereich, wird eine "`Retreat"'-Operation auf der
internen "`agentclaim\char`_t"'-Struktur ausgeführt und zusätzlich die Constraints des Claims gelöscht. Dieses implizite Retreat
stellt sicher, dass die vom Claim verwendeten Ressourcen nach dem Gebrauch wieder freigegeben werden und somit anderen
Programmteilen zur Verfügung stehen.
