\chapter{Entwurf und Implementierung}\label{sec:impl}

%TODO Formattieren von Befehlen, Namen etc.

Im folgenden werden Programme und Bibliotheken entwickelt, welche es ermöglichen, Rust auf dem IRTSS Betriebssystem
verwenden zu können. Dies ermöglicht es dann, Programme welche vom invasiven Computing Gebrauch machen, in der
Programmiersprache Rust zu schreiben.

\section{Rust auf der SPARC LEON Architektur}

Rust wird derzeit nicht offiziell auf der SPARC-V8 Architektur unterstützt. Rust verwendet jedoch als Backend LLVM,
welches diese Architektur unterstützt und daher ist es prinzipiell möglich, Rust-Programme für diese Architektur zu kompilieren.
Die Rust-Standardbibliothek ist jedoch nicht trivial auf andere Architekturen zu portieren, Rust bietet allerdings die Funktion,
Programme mit einer minimalen, platformunabhängigen Untermenge der Standardbibliothek zu kompilieren. Diese Funktion wird hier
ausgenutzt, um eine minimale Implementierung der Programmiersprache auf die SPARC-V8 Architektur zu portieren.

% Hierfür wird jedoch eine bereits kompiliertes Core-Crate (libcore) benötigt, denn dieses enthält die
% Grundfuktionen der Programmiersprache. Daher muss zunächst dieses Crate für die SPARC LEON Architektur kompiliert werden.

% Der Rust-Compiler rustc erlaubt es mithilfe der \colorbox{lightgray}{-{}-target} Option, ein Rust-Programm für eine beliebige
% Ziel-Architektur zu kompilieren.

Um ein Rust Programm für eine nicht offiziell unterstütze Architektur zu kompilieren, muss man zuerst die libcore Bibliothek
für die Zielarchitektur kompilieren. Um dies zu erreichen, benötigt man eine JSON-Datei, welche
dem Compiler die nötigen Informationen zur Ziel-Architektur zur Verfügung stellt. Eine solche JSON Datei für die
SPARC-V8 Architektur sieht beispielsweise wie folgt aus\cite{initialSparcSupportGithub}:
\begin{verbatim}
{
    "arch": "sparc",
    "data-layout": "E-m:e-p:32:32-i64:64-f128:64-n32-S64",
    "executables": true,
    "llvm-target": "sparc",
    "os": "none",
    "panic-strategy": "abort",
    "target-endian": "big",
    "target-pointer-width": "32",
    "linker-flavor": "ld",
    "linker": "path_to_sparc_gcc",
    "link-args": [
        "-nostartfiles"
    ]
}
\end{verbatim}
Außerdem wird ein C-Linker, beispielsweise gcc, für die SPARC-V8 Architektur benötigt. Der Pfad zu diesem Linker
muss in der \colorbox{lightgray}{linker}-Option der JSON-Datei angegeben werden.

Sobald man diese JSON Datei erstellt hat, kann man die libcore Bibliothek mit dem ``cargo build'' Befehl kompilieren.
Um dies für SPARC-V8 zu tun, gibt man als Parameter für die ``-{}-target''-Option den Pfad zur Spezifikations-JSON-Datei an.
Derzeit ist es nicht möglich libcore mit dem stabilen Rust-Compiler zu kompilieren, da diese Bibliothek Funktionalitäten
verwendet, welche auf dem stabilen Compiler deaktiviert sind. Daher muss ein nightly-Compiler installiert werden, welches
dank rustup jedoch relativ nutzerfreundlich gestaltet ist. Außerderm sollte die Version der libcore Bibliothek
mit der Version des nightly-Compilers übereinstimmen um versionsabhängige Konflikte bei der Kompilierung zu vermeiden.

Nachdem die libcore Bibliothek erfolgreich kompiliert wurde kann man, wenn rustup verwendet wurde um rustc und cargo zu installieren, 
die resultierende .rlib Datei anderen Rust-Programmen beim Kompilieren zur Verfügung zu stellen,
indem man diese in das korrekte ``lib'' Unterverzeichniss im lokalen ``.rustup'' Verzeichniss kopiert.
Alternativ kann man das libcore Projekt direkt durch die Abhängigkeiten in der Cargo.toml Datei
eines Cargo Projekts einbinden.

Damit ein Rust-Programm libcore anstelle der Standardbibliothek verwendet, muss man die Zeile 
\begin{verbatim} #![no_std] \end{verbatim}
zum Anfang des Programms hinzufügen. Außerdem müssen die Funktionen ``eh\char`_personality'', ``eh\char`_unwind\char`_resume'' und
``panic\char`_fmt'' in diesem Programm manuell implementiert werden. Nennenswert ist vor allem letztere, denn diese Funktion
wird aufgerufen, sobald ein Programm kontrolliert abstürzt.
Der Anfang eines zu kompilierenden Programm muss also beispielsweise wie folgt ausssehen:
\begin{verbatim}
#![feature(lang_items, libc)]
#![no_std]
#![no_main]

#[lang = "eh_personality"] extern fn eh_personality() {}
#[lang = "eh_unwind_resume"] extern fn eh_unwind_resume() {}
#[lang = "panic_fmt"] fn panic_fmt() -> ! { loop {} }
\end{verbatim}

Um dann das Programm zu kompilieren, verwendet man entweder den ``rustc'' Befehl bei eigenständigen .rs Dateien oder den
``cargo'' Befehl für Cargo Projekte. Beiden Befehlen muss dann wie auch beim Kompilieren von libcore die Speizifikations-JSON-Datei
als Argument für die ``-{}-target''-Option angegeben werden. 

\section{Erstellung des octorust Hilfsprogramms}

Um das relativ komplizierte und fehleranfällige Kompilieren für Rust-Programme auf der SPARC LEON Architektur zu vereinfachen, als
auch besagte Rust-Programme mit dem IRTSS Betriebssytem zu verwenden, wurde ein Python-Programm geschrieben, welche diese Schritte
vereinfacht. Das Programm wurde in Python geschrieben, da Python's Standardbibliothek viele nützliche Funktionen zur Manipulation
von Dateien bietet, welches sich für diesen Zweck als hilfreich erweisen. Außerdem bietet Python mit argparse ein
praktisches Modul zum Verarbeiten von von Kommandozeile-Argumenten.

Das Programm verwendet python-setuptools und eine dafür konfigurierte setup.py Datei, um das Programm lokal zu installieren.
Während dem Installationsprozesses wird zum Einen das octorust-Programm selbst lokal als Python Modul installiert und das
``octorust'' Skript als ausführbare Datei dem Nutzer zur Verfügung gestellt.
Gleichzeitig wird ein Verzeichniss names .octorust
im Heimverzeichniss des derzeitigen Nutzers erstellt, in dem IRTSS-builds, die octolib Rust-Bibliothek, welche später 
genauer erläutert wird, als auch ein SPARC-V8 gcc, insofern dass ein
solcher nicht bereits installiert ist und im Pfad gefunden werden kann.
Zudem werden für alle unterstützten Architekturen die libcore, libc und liballoc Bibliotheken kompiliert und in den
Installationspfad des derzeit verwendeten Rustup-Toolchains kopiert.

Octorust bietet die folgenden Optionen:
\begin{itemize}

	\item{-h, -{}-help}
	
	Diese Option druckt einen Nutzungshinweis inklusive aller möglichen Kommandozeilenoptionen.
	
	\item{-a. -{}-architecture}
	
	Diese Option ermöglicht es, eine IRTSS Zielarchitektur zu wählen. Zur Wahl stehen ``x86guest'', ``x64native'' als auch ``leon''.
	Sollte diese Option nicht angegeben werden, wird standardmäßig für die x86guest Architektur kompiliert.
	
	\item{-v, -{}-variant}
	
	Diese Option ermöglicht es, eine IRTSS-Variante zu wählen, beispielsweise ``generic'' oder 	``4t5c-nores-chipit-w-iotile''.
	Sollte diese Option nicht angegeben werden, wird je nach gewählter Architektur eine passende Standardvariante verwendet.
	Im Falle von ``x86guest'' und ``x64native'' wird die Variante ``generic'' gewählt und für ``leon'' die Variante
	``4t5c-nores-chipit-w-iotile''.
	
	\item{-o, -{}-output}
	
	Mit dieser Option kann der Pfad zur resultierenden Ausgabedatei explizit angegeben	werden. Ansonsten ermittelt octorust
	automatisch einen sinnvollen Ausgabenamen, beispielsweise ``foo.out'' für ein Cargo-Project mit dem Namen ``foo''.
	
	\item{-k, -{}-keep}
	
	Wird diese Option verwendet, werden jegliche temporäre Dateien, die während dem Kompilieren und dem Linken erstellt werden im
	Anschluss nicht gelöscht. Dies beinhaltet beispielsweise statische Bibliotheken oder Objekt-Dateien.
	
	\item{-r, -{}-run}
	
	Wird diese Option verwendet, wird das Programm nach dem Kompilieren sofort ausgeführt. Für andere Architekturen als
	``x86guest'' wird dabei vorausgesetzt dass das Virtualisierungsprogramm ``qemu'' installiert ist.
	
	\item{-i, -{}-irtss-build-version}

	Mithilfe dieser Option kann man eine spezifische IRTSS Version verwenden.
	
	\item{-{}-release}

	Wird diese Option verwendet, werden Compiler-Optimierungen für Rust-Programme aktiviert.
	
	\item{-{}-fetch-irtss}

	Mithilfe dieser Option können IRTSS-builds von https://www4.cs.fau.de/invasic/octopos/ heruntergeladen werden. Hierfür ist jedoch
	eine gültige Nutzername/Passwort-Kombination in einer .netrc Datei im folgenden Format vonnöten:
	\begin{verbatim}
	machine www4.cs.fau.de
	login NUTZERNAME
	password PASSWORT
	\end{verbatim}
\end{itemize}

Unterstützt wird das Kompilieren von eigenständigen .c C-Programmen und .rs Rust-Programmen, als auch das Kompilieren von
Cargo-Projekten. Cargo-Projekte bieten durch das Abhängigkeitsmanagement zusätzlich den Gebrauch von Rust-Bibliotheken, vor
allem der octolib-Bibliothek, welche eigens für die Interaktion zwischen Rust und IRTSS entwickelt wurde. Daher werden sich die
folgenden Prozesse primär mit dem Kompilierungsvorgang der Cargo-Projekte beschäftigen.

\subsection{Struktur eines invasiven Cargo-Projekts}

Wie normale Cargo-Projekte besteht ein invasives Cargo-Projekt aus mindestens einem ``src'' Verzeichnis, einer Haupt-Bibliotheksdatei
und einer ``Cargo.toml'' Datei. Bei invasiven Cargo-Projekte muss das ``crate-type'' Attribut immer als ``staticlib'' angegeben werden,
damit das Projekt als statische Bibliothek kompiliert werden kann, welche dann mit dem IRTSS Betriebssystem verlinkt werden kann.

Zusätzlich muss die Haupt-Quelldatei des Projekts mit ``\char`#![no\char`_std]'' beginnen und anstelle der main()
Funktion muss eine ``pub extern \char`"C\char`"'' Funktion namens ``rust\char`_main\char`_ilet'' als Startpunkt des Programms
verwendet werden.
Diese Funktion nimmt genau einen Parameter entgegen, welcher vom Typ u8 ist.
Über diese  Funktion muss außerdem ``\char`#[no\char`_mangle]'' stehen, damit die Funktion aus einem C Kontext heraus
aufrufbar ist.
Außerdem sollte die octolib Bibliothek mit einem ``extern crate octolib;'' eingebunden werden.

Die Haupt-Quelldatei eines invasiven Cargo-Projekts sähe demnach wie folgt aus:
\begin{verbatim}
#![no_std]

extern crate octolib;

#[no_mangle]
pub extern "C" fn rust_main_ilet(claim: u8) {

}
\end{verbatim}

\subsection{Kompilieren}

Vor der Kompilierung wird im Falle, dass ``leon' als Zielarchitektur ausgewählt wurde, zuerst eine wie in Kapitel 3.1 erläuterte
JSON-Spezifikationsdatei generiert, in der der Pfad zum SPARc-v8 gcc Compiler automatisch eingetragen wird. Für die anderen beiden
Zielarchitekturen ist ein solcher Schritt nicht nötig, da diese offiziell unterstützt werden. 
Nachdem diese Spezifikationsdatei generiert wurde, wird das Projekt mithilfe des ``cargo''-Befehls als statische Bibliothek 
kompiliert. Wurde das Projekt erfolgreich kompiliert, wird anschließend eine minimale C Datei generiert,
welche die vom IRTSS benötigte main\char`_ilet Funktion implementiert und innerhalb
dieser die rust\char`_main\char`_ilet Funktion aufruft. Im Anschluss daran wird dann noch die ``shutdown'' Funktion verwendet um die 
Ausführung des Programms zu beenden. Diese generierte C Datei wird mithilfe eines passenden gcc Compilers als object-Datei kompiliert
und anschließend mit dem IRTSS und der zuvor kompilierten statischen Rust-Bibliothek verlinkt. Nun sollte eine ausführbare Datei
existieren, welche im Falle der ``x86guest'' Architektur nativ ausführbar ist oder im Falle von ``x64native'' und ``leon''
mithilfe eines Emulators wie ``qemu''.

Im Anschluss an die Kompilierung werden, vorausgesetzt die ``--keep''-Option wurde nicht verwendet, jegliche temporäre Dateien
gelöscht, beispielsweise die generierte Cargo.toml Datei, die statische Rust-Bibliothek, die minimale C Datei oder auch die C
Objektdatei.

\section{octolib}

Zusätzlich zum octorust Programm wurde ebenfalls eine Rust-Bibliothek names octolib geschrieben. Diese Bibliothek soll
die Interaktion zwischen Rust und dem IRTSS Betriebssystem ermöglichen und and die neue Programmiersprache anpassen. IRTSS
bietet eine C-Schnittstelle an, welche man mithilfe der Foreign Function Interface und der libc Bibliothek aus Rust heraus ansprechen
kann. Die libc Bibliothek bietet die Möglichkeit, Komponenten die die Standardbibliothek benötigen auszulassen, daher ist sie
auch auf der SPARC-v8 Architektur benutzbar.

Die octolib Bibliothek wird vor dem Kompilieren als Abhängigkeit in die Cargo.toml Datei eingefügt und so dem Projekt hinzugefügt.
Damit die Bibliothek für jedes zu kompilierende Programm auffindbar ist, wird eine lokale Kopie während der Installation des
``octorust''-Programms im ``~/.octorust'' Verzeichnis erstellt.

\subsection{Struktur}

Octolib besteht aus einer Hauptbibliotheksdatei namens ``lib.rs'', welche alle anderen Module innerhalb des Projekts einbindet. Diese
Datei implementiert außerdem die in Kapitel 3.1 erwähnten Funktionen ``eh\char`_personality'', ``eh\char`_unwind\char`_resume'' und
``panic\char`_fmt'', so dass nicht jedes einzelne Projekt diese aufs Neue implementieren muss. Sobald die octolib Bibliothek
mit der Anweisung ``extern crate octolib'' ins Projekt eingebunden wurde, sind diese Funktionen ebenfalls vorhanden.

Die Bibliothek bietet die folgenden Module:

\begin{itemize}

	\item{bindings}
	
	Dieses Modul enthält die direkten C-Rust Bindings zur C-Schnittstelle des IRTSS	.
	
	\item{helper}
	
	Dieses Modul enthält eine Sammlung an Hilfsfunktionen, beispielsweise eine ohne ``unsafe''-Block verwendbare
	print-Funktion, welche von der C printf Funktion Gebrauch macht. Dies ist notwendig da Rust ohne die Standardbibliothek
	keine äquivalente Funktion besitzt.
	
	\item{improvements}
	
	Rust-spezifische Abstraktionen, die es dem Programmierer erleichtern, Programme mit Rust für das IRTSS zu schreiben.
	
	\item{octo\char`_structs}
	
	Rust-äquivalente Structs zu denen, die in der C-Schnittstelle verwendet werden.
	
	\item{octo\char`_types}
	
	Rust-äquivalente Typen zu denen, die in der C-Schnittstelle verwendet werden.

\end{itemize}

\subsection{Direkte C-Rust Bindings}

Im ersten Schritt wurden die Funktionen der C Schnittstelle direkt Eins-zu-Eins als Rust-Funktionen eingebunden. Dank der
Foreign Function Interface ist dies ein relativ simples Unterfangen, es müssen lediglich die Parameter- und Rückgabetypen
an die neue Programmiersprache angepasst werden. Für die meisten Typen gibt es direkte Äquivalente in Rust, jegliche anderen Typen
stellt die libc Bibliothek zur Verfügung. Ein nennenswertes Beispiel eines Typs der nicht in Rust enthalten ist, ist der
``void'' Typ. Dieser Typ kann beispielsweise durch den c\char`_void Typen aus der libc Bibliothek emuliert werden.
Void-Pointer (void*), welche an einigen Stellen der C-Schnittstelle verwendet werden, können so als ``*mut c\char`_void''
dargestellt werden.

Um die Funktionen erfolgreich in die Rust-Bibliothek einbinden zu können, muss man einen ``extern''-Block erstellen und dort
die Funktionsdefinitionen vornehmen. Damit diese auch von anderen Modulen oder Projekten aufgerufen werden können, müssen diese
als ``pub fn`` deklariert werden. Da diese Funktionen lediglich importierte C-Funktionen ohne jegliche Sicherheitsgarantien
sind, muss man bei jedem Gebrauch dieser Funktionen einen ``unsafe''-Block verwenden.

\subsubsection{Structs und Typen}

Zusätzlich zu den Funktionsdefinitionen mussten die in IRTSS definierten structs und Typen ebenfalls portiert werden.
Dank der \char`#[repr(C)] Anweisung kann man in Rust Structs erstellen, welche kompatibel mit den C-Äquivalenten sind.
Diese Structs sind teils von Platform-spezifischen Konstanten abhängig, welche man in Rust mit der
\char`#[cfg(target\char`_arch = "arch")] Anweisung für unterschiedliche Architekturen definieren kann.
benutzerdefinierte Typen lassen sich in Rust durch Schlüsselwort ``type'' erstellen.

\subsection{Rust-spezifische Verbesserungen}

Im folgenden werden verschiedene Abstraktionen über die direkten C-Rust Bindings erstellt, welche das Programmieren
vereinfachen und die Stärken von Rust ausnutzen sollen.

\subsubsection{Constraints}

Die ``Constraints'' Struktur ist eine leichte, objektorientierte Abstraktion für die Constraints, mit denen die Anzahl Ressourcen, die
einem Claim zur Verfügung stehen, limitiert werden.
Es bietet einen Konstruktor, welcher eine neue ``constraints\char`_t'' Struktur mithile der ``agent\char`_constr\char`_create''
Funktion aus der C-Schnittstelle erstellt und anschließend einige Standardwerte setzt. Dem Konstruktor werden
zudem 2 Parameter übergeben, welche die minimale und maximale Anzahl an Prozessorelementen spezifizieren.

Alle Parameter der Constraints lassen sich nachträglich durch Methoden der Struktur ändern. Hierbei profitiern vor allem die Methoden
die ``bool''-Werte als Parametertypen besitzen, denn diese werden in den direkten C-Rust Bindings statt mit ``bool''-Werten mit
u8-Werten aufgerufen. Dies liegt daran, dass es in C keinen ``bool'' oder ähnlichen Typen gibt, dort werden Zahlenwerte auf den
Wert 0 geprüft.

Außerdem unterstützt die Methode ``merge\char`_constraints'' anstelle einer ``constraints\char`_t'' Struktur aus der
C-Schnittstelle eine in Rust definierte ``Constraints'' Struktur.

Um Zugriff auf die ``constraints\char`_t'' Struktur zu erhalten, muss die ``to\char`_constraints\char`_t'' Methode aufgerufen werden.

\subsubsection{Closures}

Rust Closures können nicht ohne Weiteres einer C-Schnittstelle als Parameter übergeben werden. Somit ist es mit den direkten
C-Rust bindings nicht möglich, Closures zu verwenden, um Code auf den Rechenelementen auszuführen. Dies wäre jedoch eine
wünschenswerte Funktionalität. Da Closures aus der Funktion selbst als auch ihrem Erstellungskontext\cite{closureWikiDe}
bestehen, ist es nicht möglich die Closure direkt zu einer normalen Rust Funktion zu konvertieren. Stattdessen erstellt
man einen Pointer auf die Datenregion, welche die Closure repräsentiert und übergibt diesen dann einer
``extern \char`"C\char`"'' Funktion, welche aus diesem Pointer die Closure zurückgewinnt.
Diese ``extern \char`"C\char`"''-Funktion kann dann der C-Schnittstelle zusammen mit dem Pointer
auf die Closure-Daten übergeben werden.

Die Erstellung des Closure-Pointers wird direkt in der später genauer erläuterten ``infect''-Methode der ``AgentClaim''-Struktur
erledigt, während es zur Rückkonvertierung eine ``extern \char`"C\char`"''-Funktion namens execute\char`_closure erstellt wurde.

\subsubsection{AgentClaim}

Die größte Abstraktion in der octolib Bibliothek ist die ``AgentClaim'' Struktur. Diese bietet zunächst einmal eine Abstraktionsschicht
über die `agentclaim\char`_t` Struktur aus der C-Schnittstelle und verschiedene Methoden um diese zu verwenden.

Der Konstruktor nimmt als einzigen Parameter eine ``Constraints''-Struktur entgegen, welche verwendet wird um die
Ressourcen des Claims zu definieren. Mit diesen Constraints wird dann eine interne ``agentclaim\char`_t''-Struktur initialisiert,
welche für alle folgenden Methodenaufrufe verwendet wird.

Eine praktische Methode fürs Debugging ist ``set\char`_verbose''. Diese Methode erlaubt es, die Ausführlichkeit der auf
die Kommandozeile gedruckten Informationen zu beeinflussen.

Die ``reinvade''-Methode elaubt es, eine ``Reinvade''-Operation auf dem Claim auszuführen. Diese Methode nimmt einen
optionalen Parameter an, mit dem man neue Constraints setzen kann. Werden neue Constraints gesetzt, werden die alten Constraints
aus dem Speicher gelöscht. 

Die wohl wichtigste Methode der ``AgentClaim''-Struktur ist die ``infect''-Methode. Mit dieser kann eine ``Infect''-Operation
auf dem Claim ausgeführt werden. Dieser Methode wird eine Funktion oder eine Closure als Parameter übergeben, welche dann auf den
Rechenelementen des Claims ausgeführt werden. Zusätzlich können ebenfalls Parameterdaten für die einzelnen Recheneinheiten
übergeben werden.
In der ``infect''-Methode werden Signale verwendet, um die Kommunikation zwischen verschiedenen Rechenelementen zu verwalten.
Für jedes Tile und Rechenelement wird iteriert und ein ilet aus der übergegebenen Funktion generiert, welches dann der C-Schnittstelle 
übergeben wird und so dann ausgeführt wird. Anschließend wartet die Methode dann auf den erfolgreichen Abschluss aller Ilets.
%TODO Formulierung! Besser Verständlich machen!

Zusätzlich zur normalen ``infect''-Methode gibt es auch eine ``infect\char`_async''-Methode, welche nicht auf das Ende der
Ausführung aller Rechenelemente wartet, sondern stattdessen wird das Signal, mit dem die Rechenelemente signalisieren dass sie fertig
ausgeführt wurden, als Rückgabewert verwendet. Anschließend kann der Nutzer dann mithilfe dieses Signals manuell auf die
Ausführung der Rechenelemente warten.

Das bereits in Kapitel 2 erwähnte Drop-Trait für Rust Strukturen wird für die ``AgentClaim''-Struktur implementiert.
Verlässt eine Instanz der ``AgentClaim''-Struktur den gültigen Anwendungsbereich, wird eine ``Retreat''-Operation auf der
internen ``agentclaim\char`_t''-Struktur ausgeführt und zusätzlich die Contraints des Claims gelöscht. Dieses implizite Retreat
stellt sicher, dass die vom Claim verwendeten Ressourcen nach dem Gebrauch wieder freigegeben werden und somit anderen
Programmteilen zur Verfügung stehen.
